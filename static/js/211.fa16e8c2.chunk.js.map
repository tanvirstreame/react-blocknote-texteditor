{"version":3,"file":"static/js/211.fa16e8c2.chunk.js","mappings":"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","sources":["../node_modules/html-whitespace-sensitive-tag-names/lib/index.js","../node_modules/hast-util-format/lib/index.js","../node_modules/rehype-format/lib/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/index.js"],"sourcesContent":["/**\n * List of HTML tag names that are whitespace sensitive.\n */\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n","/**\n * @import {Nodes, RootContent, Root} from 'hast'\n * @import {BuildVisitor} from 'unist-util-visit-parents'\n * @import {Options, State} from './types.js'\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Root} tree\n *   Tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport function format(tree, options) {\n  const settings = options || emptyOptions\n\n  /** @type {State} */\n  const state = {\n    blanks: settings.blanks || [],\n    head: false,\n    indentInitial: settings.indentInitial !== false,\n    indent:\n      typeof settings.indent === 'number'\n        ? ' '.repeat(settings.indent)\n        : typeof settings.indent === 'string'\n          ? settings.indent\n          : '  '\n  }\n\n  minifyWhitespace(tree, {newlines: true})\n\n  visitParents(tree, visitor)\n\n  /**\n   * @type {BuildVisitor<Root>}\n   */\n  function visitor(node, parents) {\n    if (!('children' in node)) {\n      return\n    }\n\n    if (node.type === 'element' && node.tagName === 'head') {\n      state.head = true\n    }\n\n    if (state.head && node.type === 'element' && node.tagName === 'body') {\n      state.head = false\n    }\n\n    if (\n      node.type === 'element' &&\n      whitespaceSensitiveTagNames.includes(node.tagName)\n    ) {\n      return SKIP\n    }\n\n    // Donâ€™t indent content of whitespace-sensitive nodes / inlines.\n    if (node.children.length === 0 || !padding(state, node)) {\n      return\n    }\n\n    let level = parents.length\n\n    if (!state.indentInitial) {\n      level--\n    }\n\n    let eol = false\n\n    // Indent newlines in `text`.\n    for (const child of node.children) {\n      if (child.type === 'comment' || child.type === 'text') {\n        if (child.value.includes('\\n')) {\n          eol = true\n        }\n\n        child.value = child.value.replace(\n          / *\\n/g,\n          '$&' + state.indent.repeat(level)\n        )\n      }\n    }\n\n    /** @type {Array<RootContent>} */\n    const result = []\n    /** @type {RootContent | undefined} */\n    let previous\n\n    for (const child of node.children) {\n      if (padding(state, child) || (eol && !previous)) {\n        addBreak(result, level, child)\n        eol = true\n      }\n\n      previous = child\n      result.push(child)\n    }\n\n    if (previous && (eol || padding(state, previous))) {\n      // Ignore trailing whitespace (if that already existed), as weâ€™ll add\n      // properly indented whitespace.\n      if (whitespace(previous)) {\n        result.pop()\n        previous = result[result.length - 1]\n      }\n\n      addBreak(result, level - 1)\n    }\n\n    node.children = result\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(state, previous) && blank(state, next) ? '\\n\\n' : '\\n') +\n      state.indent.repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes | undefined} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is a blank.\n */\nfunction blank(state, node) {\n  return Boolean(\n    node &&\n      node.type === 'element' &&\n      state.blanks.length > 0 &&\n      state.blanks.includes(node.tagName)\n  )\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(state, node) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? state.head ||\n        node.tagName === 'script' ||\n        embedded(node) ||\n        !phrasing(node)\n      : false)\n  )\n}\n","/**\n * @import {Options} from 'hast-util-format'\n * @import {Root} from 'hast'\n */\n\nimport {format} from 'hast-util-format'\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    format(tree, options)\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodeâ€™s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodeâ€™s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnâ€™t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n"],"names":["whitespaceSensitiveTagNames","emptyOptions","blank","state","node","Boolean","type","blanks","length","includes","tagName","padding","head","embedded","phrasing","rehypeFormat","options","tree","settings","indentInitial","indent","repeat","addBreak","list","level","next","tail","previous","whitespace","replace","Math","max","value","push","minifyWhitespace","newlines","visitParents","parents","SKIP","children","eol","child","result","pop","format","convert","test","undefined","ok","castFactory","Array","isArray","tests","checks","index","any","_len","arguments","parameters","_key","apply","this","anyFactory","check","checkAsRecord","all","nodeAsRecord","key","propsFactory","typeFactory","Error","testFunction","parent","looksLikeANode","call","empty","CONTINUE","EXIT","visitor","reverse","is","step","factory","name","Object","defineProperty","visit","subresult","offset","grandparents","toResult","nodeAsParent","concat"],"sourceRoot":""}