{"version":3,"file":"static/js/991.57d3ca1c.chunk.js","mappings":"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","sources":["../node_modules/micromark-util-decode-numeric-character-reference/index.js","../node_modules/mdast-util-to-markdown/lib/configure.js","../node_modules/mdast-util-to-markdown/lib/join.js","../node_modules/mdast-util-to-markdown/lib/unsafe.js","../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-to-markdown/lib/index.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/remark-stringify/lib/index.js","../node_modules/zwitch/index.js","../node_modules/micromark-util-decode-string/index.js","../node_modules/decode-named-character-reference/index.dom.js"],"sourcesContent":["/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCodePoint(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base);\n  if (\n  // C0 except for HT, LF, FF, CR, space.\n  code < 9 || code === 11 || code > 13 && code < 32 ||\n  // Control character (DEL) of C0, and C1 controls.\n  code > 126 && code < 160 ||\n  // Lone high surrogates and low surrogates.\n  code > 55_295 && code < 57_344 ||\n  // Noncharacters.\n  code > 64_975 && code < 65_008 || /* eslint-disable no-bitwise */\n  (code & 65_535) === 65_535 || (code & 65_535) === 65_534 || /* eslint-enable no-bitwise */\n  // Out of range\n  code > 1_114_111) {\n    return \"\\uFFFD\";\n  }\n  return String.fromCodePoint(code);\n}","/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n","/**\n * @import {Join} from 'mdast-util-to-markdown'\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @import {AssociationId} from '../types.js'\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @import {CompilePattern} from '../types.js'\n */\n\n/**\n * @type {CompilePattern}\n */\nexport function compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {FlowChildren, FlowParents, TrackFields} from '../types.js'\n */\n\n/**\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {FlowChildren} left\n * @param {FlowChildren} right\n * @param {FlowParents} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @import {IndentLines} from '../types.js'\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @import {CreateTracker, TrackCurrent, TrackMove, TrackShift} from '../types.js'\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Info, Join, Options, SafeConfig, State} from 'mdast-util-to-markdown'\n * @import {Nodes} from 'mdast'\n * @import {Enter, FlowParents, PhrasingParents, TrackFields} from './types.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options) {\n  const settings = options || {}\n  /** @type {State} */\n  const state = {\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    enter,\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined,\n    indentLines,\n    indexStack: [],\n    join: [...join],\n    options: {},\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe]\n  }\n\n  configure(state, settings)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {import('unified').Compiler<Root, string>} Compiler\n * @typedef {import('unified').Processor<undefined, undefined, undefined, Root, string>} Processor\n */\n\n/**\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * Add support for serializing to markdown.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkStringify(options) {\n  /** @type {Processor} */\n  // @ts-expect-error: TS in JSDoc generates wrong types if `this` is typed regularly.\n  const self = this\n\n  self.compiler = compiler\n\n  /**\n   * @type {Compiler}\n   */\n  function compiler(tree) {\n    return toMarkdown(tree, {\n      ...self.data('settings'),\n      ...options,\n      // Note: this option is not in the readme.\n      // The goal is for it to be set by plugins on `data` instead of being\n      // passed by users.\n      extensions: self.data('toMarkdownExtensions') || []\n    })\n  }\n}\n","/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it’s value is this function’s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it’s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn’t have a `key` property, the special\n   * “invalid” handler will be called.\n   * If `value` has an unknown `key`, the special “unknown” handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it’s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it’s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n","import { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nconst characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @param {string} $1\n *   Character escape.\n * @param {string} $2\n *   Character reference.\n * @returns {string}\n *   Decoded value\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0);\n  if (head === 35) {\n    const head = $2.charCodeAt(1);\n    const hex = head === 120 || head === 88;\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}","/// <reference lib=\"dom\" />\n\n/* global document */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n"],"names":["decodeNumericCharacterReference","value","base","code","Number","parseInt","String","fromCodePoint","own","hasOwnProperty","configure","extension","key","index","extensions","length","call","list","map","options","left","right","push","Object","assign","join","parent","state","type","formatCodeAsIndented","spread","formatHeadingAsSetext","fullPhrasingSpans","unsafe","character","after","inConstruct","before","notInConstruct","atBreak","association","node","label","identifier","decodeString","compilePattern","pattern","_compiled","RegExp","test","between","result","repeat","eol","indentLines","match","start","line","exec","one","slice","numerical","a","b","escapeBackslashes","expression","positions","results","whole","track","config","now","lineShift","column","move","input","chunks","split","tail","current","shift","toMarkdown","tree","settings","associationId","containerPhrasing","containerPhrasingBound","containerFlow","containerFlowBound","createTracker","enter","name","stack","pop","handlers","_objectSpread","handle","undefined","indexStack","safe","safeBound","tightDefinitions","joinDefinition","zwitch","invalid","unknown","charCodeAt","Error","info","children","encodeAfter","tracker","child","peek","charAt","replace","encodeCharacterReference","encodingInfo","attentionEncodeSurroundingInfo","this","bulletLastUsed","infos","patternInScope","Boolean","position","includes","sort","end","encode","remarkStringify","self","compiler","data","fn","id","_len","arguments","parameters","Array","_key","characterEscapeOrReference","decode","$0","$1","$2","head","hex","decodeNamedCharacterReference","element","document","createElement","characterReference","innerHTML","textContent"],"sourceRoot":""}