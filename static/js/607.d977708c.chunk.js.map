{"version":3,"file":"static/js/607.d977708c.chunk.js","mappings":"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","sources":["../node_modules/@ungap/structured-clone/esm/types.js","../node_modules/@ungap/structured-clone/esm/deserialize.js","../node_modules/@ungap/structured-clone/esm/serialize.js","../node_modules/@ungap/structured-clone/esm/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/mdast-util-phrasing/lib/index.js","../node_modules/unist-util-position/lib/index.js","../node_modules/unist-util-find-after/lib/index.js","../node_modules/hast-util-to-text/lib/index.js","../node_modules/trim-trailing-lines/index.js","../node_modules/hast-util-to-mdast/lib/handlers/code.js","../node_modules/hast-util-to-mdast/lib/handlers/del.js","../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../node_modules/hast-util-to-mdast/lib/handlers/em.js","../node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js","../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../node_modules/hast-util-to-mdast/lib/handlers/img.js","../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../node_modules/hast-util-to-mdast/lib/handlers/li.js","../node_modules/hast-util-to-mdast/lib/handlers/list.js","../node_modules/hast-util-to-mdast/lib/util/wrap.js","../node_modules/hast-util-to-mdast/lib/handlers/media.js","../node_modules/hast-util-to-mdast/lib/handlers/p.js","../node_modules/hast-util-to-mdast/lib/handlers/q.js","../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../node_modules/hast-util-to-mdast/lib/handlers/table.js","../node_modules/hast-util-to-mdast/lib/handlers/index.js","../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../node_modules/hast-util-to-mdast/lib/handlers/root.js","../node_modules/hast-util-to-mdast/lib/handlers/text.js","../node_modules/hast-util-to-mdast/lib/handlers/a.js","../node_modules/hast-util-to-mdast/lib/handlers/base.js","../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../node_modules/hast-util-to-mdast/lib/handlers/br.js","../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../node_modules/hast-util-to-mdast/lib/handlers/input.js","../node_modules/hast-util-to-mdast/lib/handlers/select.js","../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../node_modules/hast-util-to-mdast/lib/state.js","../node_modules/hast-util-to-mdast/lib/index.js","../node_modules/rehype-minify-whitespace/lib/index.js","../node_modules/rehype-remark/lib/index.js"],"sourcesContent":["export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n","import {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} any a serializable value.\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\n * a transfer option (ignored when polyfilled) and/or non standard fields that\n * fallback to the polyfill if present.\n * @returns {Record[]}\n */\nexport default typeof structuredClone === \"function\" ?\n  /* c8 ignore start */\n  (any, options) => (\n    options && ('json' in options || 'lossy' in options) ?\n      deserialize(serialize(any, options)) : structuredClone(any)\n  ) :\n  (any, options) => deserialize(serialize(any, options));\n  /* c8 ignore stop */\n\nexport {deserialize, serialize};\n","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodeâ€™s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * > ðŸ‘‰ **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\n */\n\n/**\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n *\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` â€” space\n *   *   `1` â€” line ending\n *   *   `2` â€” blank line\n *\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n *\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n *\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\n *   Any value for a break before.\n *\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use (default: `'normal'`).\n */\n\nimport {findAfter} from 'unist-util-find-after'\nimport {convertElement} from 'hast-util-is-element'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst cell = convertElement(isCell)\nconst p = convertElement('p')\nconst row = convertElement('tr')\n\n// Note that we donâ€™t need to include void elements here as they donâ€™t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'li', // Lists (as `display: list-item`)\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > ðŸ‘‰ **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > weâ€™re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), weâ€™ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Nodes} tree\n *   Tree to turn into text.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options) {\n  const options_ = options || {}\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the nodeâ€™s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: weâ€™re not supporting stylesheets so weâ€™re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: weâ€™ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if weâ€™re here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? undefined : block,\n          breakAfter:\n            index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\n *\n * @param {Nodes} node\n * @param {Parents} parent\n * @param {CollectionInfo} info\n * @returns {Array<BreakNumber | string>}\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parents} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<BreakNumber | string>} */\n  let items = []\n\n  // Weâ€™re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If nodeâ€™s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If nodeâ€™s computed value of `display` is `table-row`, and nodeâ€™s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (\n    row(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, row)\n  ) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If nodeâ€™s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If nodeâ€™s computed value of `display` is `table-cell`, and nodeâ€™s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (\n    cell(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, cell)\n  ) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we donâ€™t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Comment | Text} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<BreakNumber | string>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [â€¦] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and itâ€™s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // donâ€™t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as â€œpreâ€ whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     spaceâ€”even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     contextâ€”is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If weâ€™re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and thereâ€™s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We donâ€™t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Nodes} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return properties.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {properties: {hidden: true}}}\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {tagName: 'td' | 'th'}}\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th'\n}\n\n/**\n * @type {TestFunction}\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Code} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\n\nconst prefix = 'language-'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Code}\n *   mdast node.\n */\nexport function code(state, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<number | string> | undefined} */\n  let classList\n  /** @type {string | undefined} */\n  let lang\n\n  if (node.tagName === 'pre') {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        child.type === 'element' &&\n        child.tagName === 'code' &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  /** @type {Code} */\n  const result = {\n    type: 'code',\n    lang: lang || null,\n    meta: null,\n    value: trimTrailingLines(toText(node))\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Delete, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Delete}\n *   mdast node.\n */\nexport function del(state, node) {\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n  /** @type {Delete} */\n  const result = {type: 'delete', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {ListContent} from 'mdast'\n */\n\n/**\n * Infer whether list items are spread.\n *\n * @param {Readonly<Array<Readonly<ListContent>>>} children\n *   List items.\n * @returns {boolean}\n *   Whether one or more list items are spread.\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {ElementContent, Element} from 'hast'\n * @import {BlockContent, DefinitionContent, ListContent, ListItem, List} from 'mdast'\n */\n\n/**\n * @typedef Group\n *   Title/definition group.\n * @property {Array<Element>} titles\n *   One or more titles.\n * @property {Array<ElementContent>} definitions\n *   One or more definitions.\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List | undefined}\n *   mdast node.\n */\nexport function dl(state, node) {\n  /** @type {Array<ElementContent>} */\n  const clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  let index = -1\n\n  // Unwrap `<div>`s\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'div') {\n      clean.push(...child.children)\n    } else {\n      clean.push(child)\n    }\n  }\n\n  /** @type {Group} */\n  let group = {definitions: [], titles: []}\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    const child = clean[index]\n\n    if (child.type === 'element' && child.tagName === 'dt') {\n      const previous = clean[index - 1]\n\n      if (\n        previous &&\n        previous.type === 'element' &&\n        previous.tagName === 'dd'\n      ) {\n        groups.push(group)\n        group = {definitions: [], titles: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<ListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    const result = [\n      ...handle(state, groups[index].titles),\n      ...handle(state, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    /** @type {List} */\n    const result = {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(content),\n      children: content\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Array<ElementContent>} children\n *   hast element children to transform.\n * @returns {Array<BlockContent | DefinitionContent>}\n *   mdast nodes.\n */\nfunction handle(state, children) {\n  const nodes = state.all({type: 'root', children})\n  const listItems = state.toSpecificContent(nodes, create)\n\n  if (listItems.length === 0) {\n    return []\n  }\n\n  if (listItems.length === 1) {\n    return listItems[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(listItems),\n      children: listItems\n    }\n  ]\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Emphasis, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Emphasis}\n *   mdast node.\n */\nexport function em(state, node) {\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Emphasis} */\n  const result = {type: 'emphasis', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Nodes} from 'mdast'\n */\n\n/**\n * Drop trailing initial and final `br`s.\n *\n * @template {Nodes} Node\n *   Node type.\n * @param {Array<Node>} nodes\n *   List of nodes.\n * @returns {Array<Node>}\n *   List of nodes w/o `break`s.\n */\nexport function dropSurroundingBreaks(nodes) {\n  let start = 0\n  let end = nodes.length\n\n  while (start < end && nodes[start].type === 'break') start++\n  while (end > start && nodes[end - 1].type === 'break') end--\n\n  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Heading, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Heading}\n *   mdast node.\n */\nexport function heading(state, node) {\n  const depth = /** @type {Heading['depth']} */ (\n    /* c8 ignore next */\n    Number(node.tagName.charAt(1)) || 1\n  )\n  const children = dropSurroundingBreaks(\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  /** @type {Heading} */\n  const result = {type: 'heading', depth, children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Image}\n *   mdast node.\n */\nexport function img(state, node) {\n  const properties = node.properties || {}\n\n  /** @type {Image} */\n  const result = {\n    type: 'image',\n    url: state.resolve(String(properties.src || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    alt: properties.alt ? String(properties.alt) : ''\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {InlineCode} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {InlineCode}\n *   mdast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {InlineCode} */\n  const result = {type: 'inlineCode', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Element, Properties} from 'hast'\n */\n\n/**\n * @typedef {[string, Value]} Option\n *   Option, where the item at `0` is the label, the item at `1` the value.\n *\n * @typedef {Array<Option>} Options\n *   List of options.\n *\n * @typedef {string | undefined} Value\n *   `value` field of option.\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {Readonly<Element>} node\n *   hast element to inspect.\n * @param {Properties | undefined} [explicitProperties]\n *   Properties to use, normally taken from `node`, but can be changed.\n * @returns {Options}\n *   Options.\n */\nexport function findSelectedOptions(node, explicitProperties) {\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Options} */\n  const values = []\n  const properties = explicitProperties || node.properties || {}\n  const options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(properties.size), 10), 0) ||\n    (properties.multiple ? 4 : 1)\n  let index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n\n    if (option && option.properties && option.properties.selected) {\n      selectedOptions.push(option)\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  const max = Math.min(list.length, size)\n  index = -1\n\n  while (++index < max) {\n    const option = list[index]\n    const properties = option.properties || {}\n    const content = toText(option)\n    const label = content || String(properties.label || '')\n    const value = String(properties.value || '') || content\n    values.push([value, label === value ? undefined : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Element} node\n *   Parent to find in.\n * @returns {Array<Element>}\n *   Option elements.\n */\nfunction findOptions(node) {\n  /** @type {Array<Element>} */\n  const results = []\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if ('children' in child && Array.isArray(child.children)) {\n      results.push(...findOptions(child))\n    }\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'option' &&\n      (!child.properties || !child.properties.disabled)\n    ) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem} from 'mdast'\n */\n\n/**\n * @typedef ExtractResult\n *   Result of extracting a leading checkbox.\n * @property {Element | undefined} checkbox\n *   The checkbox that was removed, if any.\n * @property {Element} rest\n *   If there was a leading checkbox, a deep clone of the node w/o the leading\n *   checkbox; otherwise a reference to the given, untouched, node.\n */\n\nimport {phrasing} from 'hast-util-phrasing'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ListItem}\n *   mdast node.\n */\nexport function li(state, node) {\n  // If the list item starts with a checkbox, remove the checkbox and mark the\n  // list item as a GFM task list item.\n  const {rest, checkbox} = extractLeadingCheckbox(node)\n  const checked = checkbox ? Boolean(checkbox.properties.checked) : null\n  const spread = spreadout(rest)\n  const children = state.toFlow(state.all(rest))\n\n  /** @type {ListItem} */\n  const result = {type: 'listItem', spread, checked, children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Check if an element should spread out.\n *\n * The reason to spread out a markdown list item is primarily whether writing\n * the equivalent in markdown, would yield a spread out item.\n *\n * A spread out item results in `<p>` and `</p>` tags.\n * Otherwise, the phrasing would be output directly.\n * We can check for that: if thereâ€™s a `<p>` element, spread it out.\n *\n * But what if there are no paragraphs?\n * In that case, we can also assume that if two â€œblockâ€ things were written in\n * an item, that it is spread out, because blocks are typically joined by blank\n * lines, which also means a spread item.\n *\n * Lastly, because in HTML things can be wrapped in a `<div>` or similar, we\n * delve into non-phrasing elements here to figure out if they themselves\n * contain paragraphs or 2 or more flow non-phrasing elements.\n *\n * @param {Readonly<Element>} node\n * @returns {boolean}\n */\nfunction spreadout(node) {\n  let index = -1\n  let seenFlow = false\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element') {\n      if (phrasing(child)) continue\n\n      if (child.tagName === 'p' || seenFlow || spreadout(child)) {\n        return true\n      }\n\n      seenFlow = true\n    }\n  }\n\n  return false\n}\n\n/**\n * Extract a leading checkbox from a list item.\n *\n * If there was a leading checkbox, makes a deep clone of the node w/o the\n * leading checkbox; otherwise a reference to the given, untouched, node is\n * given back.\n *\n * So for example:\n *\n * ```html\n * <li><input type=\"checkbox\">Text</li>\n * ```\n *\n * â€¦becomes:\n *\n * ```html\n * <li>Text</li>\n * ```\n *\n * ```html\n * <li><p><input type=\"checkbox\">Text</p></li>\n * ```\n *\n * â€¦becomes:\n *\n * ```html\n * <li><p>Text</p></li>\n * ```\n *\n * @param {Readonly<Element>} node\n * @returns {ExtractResult}\n */\nfunction extractLeadingCheckbox(node) {\n  const head = node.children[0]\n\n  if (\n    head &&\n    head.type === 'element' &&\n    head.tagName === 'input' &&\n    head.properties &&\n    (head.properties.type === 'checkbox' || head.properties.type === 'radio')\n  ) {\n    const rest = {...node, children: node.children.slice(1)}\n    return {checkbox: head, rest}\n  }\n\n  // The checkbox may be nested in another element.\n  // If the first element has children, look for a leading checkbox inside it.\n  //\n  // This only handles nesting in `<p>` elements, which is most common.\n  // Itâ€™s possible a leading checkbox might be nested in other types of flow or\n  // phrasing elements (and *deeply* nested, which is not possible with `<p>`).\n  // Limiting things to `<p>` elements keeps this simpler for now.\n  if (head && head.type === 'element' && head.tagName === 'p') {\n    const {checkbox, rest: restHead} = extractLeadingCheckbox(head)\n\n    if (checkbox) {\n      const rest = {...node, children: [restHead, ...node.children.slice(1)]}\n      return {checkbox, rest}\n    }\n  }\n\n  return {checkbox: undefined, rest: node}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem, List} from 'mdast'\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List}\n *   mdast node.\n */\nexport function list(state, node) {\n  const ordered = node.tagName === 'ol'\n  const children = state.toSpecificContent(state.all(node), create)\n  /** @type {number | null} */\n  let start = null\n\n  if (ordered) {\n    start =\n      node.properties && node.properties.start\n        ? Number.parseInt(String(node.properties.start), 10)\n        : 1\n  }\n\n  /** @type {List} */\n  const result = {\n    type: 'list',\n    ordered,\n    start,\n    spread: listItemsSpread(children),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {} from 'mdast-util-to-hast'\n * @import {\n *   BlockContent,\n *   Delete,\n *   Link,\n *   Nodes,\n *   Paragraph,\n *   Parents,\n *   PhrasingContent,\n *   RootContent\n * } from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\nimport {dropSurroundingBreaks} from './drop-surrounding-breaks.js'\n\n/**\n * Check if there are phrasing mdast nodes.\n *\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesnâ€™t need a wrapper paragraph.\n *\n * @param {Array<Nodes>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap runs of phrasing content into paragraphs, leaving the non-phrasing\n * content as-is.\n *\n * @param {Array<RootContent>} nodes\n *   Content.\n * @returns {Array<BlockContent>}\n *   Content where phrasing is wrapped in paragraphs.\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing, function (d) {\n    return d\n  })\n\n  /**\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<Paragraph>}\n   */\n  function onphrasing(nodes) {\n    return nodes.every(function (d) {\n      return d.type === 'text' ? whitespace(d.value) : false\n    })\n      ? []\n      : [{type: 'paragraph', children: dropSurroundingBreaks(nodes)}]\n  }\n}\n\n/**\n * @param {Delete | Link} node\n * @returns {Array<BlockContent>}\n */\nfunction split(node) {\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<BlockContent>}\n   */\n  function onphrasing(nodes) {\n    const newParent = cloneWithoutChildren(node)\n    newParent.children = nodes\n    // @ts-expect-error Assume fine.\n    return [newParent]\n  }\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {BlockContent} child\n   * @returns {BlockContent}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const newParent = cloneWithoutChildren(node)\n      const newChild = cloneWithoutChildren(child)\n      // @ts-expect-error Assume fine.\n      newParent.children = child.children\n      // @ts-expect-error Assume fine.\n      newChild.children.push(newParent)\n      return newChild\n    }\n\n    return {...child}\n  }\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of input nodes.\n * @param {(nodes: Array<PhrasingContent>) => Array<BlockContent>} onphrasing\n *   Turn phrasing content into block content.\n * @param {(node: BlockContent) => BlockContent} onnonphrasing\n *   Map block content (defaults to keeping them as-is).\n * @returns {Array<BlockContent>}\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const flattened = flatten(nodes)\n  /** @type {Array<BlockContent>} */\n  const result = []\n  /** @type {Array<PhrasingContent>} */\n  let queue = []\n  let index = -1\n\n  while (++index < flattened.length) {\n    const node = flattened[index]\n\n    if (phrasing(node)) {\n      queue.push(node)\n    } else {\n      if (queue.length > 0) {\n        result.push(...onphrasing(queue))\n        queue = []\n      }\n\n      // @ts-expect-error Assume non-phrasing.\n      result.push(onnonphrasing(node))\n    }\n  }\n\n  if (queue.length > 0) {\n    result.push(...onphrasing(queue))\n    queue = []\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of nodes, will unravel `delete` and `link`.\n * @returns {Array<RootContent>}\n *   Unraveled nodes.\n */\nfunction flatten(nodes) {\n  /** @type {Array<RootContent>} */\n  const flattened = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we donâ€™t need to worry about that.\n    // `map` maps to its content, so we donâ€™t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What weâ€™ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened.push(...split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {Nodes} node\n *   mdast node to check.\n * @returns {node is PhrasingContent}\n *   Whether `node` is phrasing content (includes nodes with `hName` fields\n *   set to phrasing hast element names).\n */\nfunction phrasing(node) {\n  const tagName = node.data && node.data.hName\n  return tagName\n    ? hastPhrasing({type: 'element', tagName, properties: {}, children: []})\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {Parents} ParentType\n *   Parent type.\n * @param {ParentType} node\n *   Node to clone.\n * @returns {ParentType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return structuredClone({...node, children: []})\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, PhrasingContent, RootContent as MdastRootContent, Root} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {EXIT, visit} from 'unist-util-visit'\nimport {wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent> | Link}\n *   mdast node.\n */\nexport function media(state, node) {\n  const properties = node.properties || {}\n  const poster = node.tagName === 'video' ? String(properties.poster || '') : ''\n  let source = String(properties.src || '')\n  let index = -1\n  let linkInFallbackContent = false\n  let nodes = state.all(node)\n\n  /** @type {Root} */\n  const fragment = {type: 'root', children: nodes}\n\n  visit(fragment, function (node) {\n    if (node.type === 'link') {\n      linkInFallbackContent = true\n      return EXIT\n    }\n  })\n\n  // If the content links to something, or if itâ€™s not phrasingâ€¦\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!source && ++index < node.children.length) {\n    const child = node.children[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'source' &&\n      child.properties\n    ) {\n      source = String(child.properties.src || '')\n    }\n  }\n\n  // If thereâ€™s a poster defined on the video, create an image.\n  if (poster) {\n    /** @type {Image} */\n    const image = {\n      type: 'image',\n      title: null,\n      url: state.resolve(poster),\n      alt: toString(nodes)\n    }\n    state.patch(node, image)\n    nodes = [image]\n  }\n\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (nodes)\n\n  // Link to the media resource.\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: properties.title ? String(properties.title) : null,\n    url: state.resolve(source),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Paragraph, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Paragraph | undefined}\n *   mdast node.\n */\nexport function p(state, node) {\n  const children = dropSurroundingBreaks(\n    // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n    // We also support straddling later.\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  if (children.length > 0) {\n    /** @type {Paragraph} */\n    const result = {type: 'paragraph', children}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RootContent as MdastRootContent} from 'mdast'\n */\n\nconst defaultQuotes = ['\"']\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent>}\n *   mdast nodes.\n */\nexport function q(state, node) {\n  const quotes = state.options.quotes || defaultQuotes\n\n  state.qNesting++\n  const contents = state.all(node)\n  state.qNesting--\n\n  const quote = quotes[state.qNesting % quotes.length]\n  const head = contents[0]\n  const tail = contents[contents.length - 1]\n  const open = quote.charAt(0)\n  const close = quote.length > 1 ? quote.charAt(1) : quote\n\n  if (head && head.type === 'text') {\n    head.value = open + head.value\n  } else {\n    contents.unshift({type: 'text', value: open})\n  }\n\n  if (tail && tail.type === 'text') {\n    tail.value += close\n  } else {\n    contents.push({type: 'text', value: close})\n  }\n\n  return contents\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, Strong} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Strong}\n *   mdast node.\n */\nexport function strong(state, node) {\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Strong} */\n  const result = {type: 'strong', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, TableCell} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableCell}\n *   mdast node.\n */\nexport function tableCell(state, node) {\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {TableCell} */\n  const result = {type: 'tableCell', children}\n  state.patch(node, result)\n\n  if (node.properties) {\n    const rowSpan = node.properties.rowSpan\n    const colSpan = node.properties.colSpan\n\n    if (rowSpan || colSpan) {\n      const data = /** @type {Record<string, unknown>} */ (\n        result.data || (result.data = {})\n      )\n      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan\n      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan\n    }\n  }\n\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RowContent, TableRow} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableRow}\n *   mdast node.\n */\nexport function tableRow(state, node) {\n  const children = state.toSpecificContent(state.all(node), create)\n\n  /** @type {TableRow} */\n  const result = {type: 'tableRow', children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {RowContent}\n */\nfunction create() {\n  return {type: 'tableCell', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {AlignType, RowContent, TableContent, Table, Text} from 'mdast'\n */\n\n/**\n * @typedef Info\n *   Inferred info on a table.\n * @property {Array<AlignType>} align\n *   Alignment.\n * @property {boolean} headless\n *   Whether a `thead` is missing.\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Table | Text}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function table(state, node) {\n  // Ignore nested tables.\n  if (state.inTable) {\n    /** @type {Text} */\n    const result = {type: 'text', value: toText(node)}\n    state.patch(node, result)\n    return result\n  }\n\n  state.inTable = true\n\n  const {align, headless} = inspect(node)\n  const rows = state.toSpecificContent(state.all(node), createRow)\n\n  // Add an empty header row.\n  if (headless) {\n    rows.unshift(createRow())\n  }\n\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const row = rows[rowIndex]\n    const cells = state.toSpecificContent(row.children, createCell)\n    row.children = cells\n  }\n\n  let columns = 1\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const data = /** @type {Record<string, unknown>} */ (cell.data)\n        const colSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1\n        const rowSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Donâ€™t add rows that donâ€™t exist.\n                // Browsers donâ€™t render them either.\n                break\n              }\n\n              /** @type {Array<RowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('hastUtilToMdastTemporaryColSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryColSpan\n        if ('hastUtilToMdastTemporaryRowSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryRowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  state.inTable = false\n\n  /** @type {Table} */\n  const result = {type: 'table', align, children: rows}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Readonly<Element>} node\n *   Table element to check.\n * @returns {Info}\n *   Info.\n */\nfunction inspect(node) {\n  /** @type {Info} */\n  const info = {align: [null], headless: true}\n  let rowIndex = 0\n  let cellIndex = 0\n\n  visit(node, function (child) {\n    if (child.type === 'element') {\n      // Donâ€™t enter nested tables.\n      if (child.tagName === 'table' && node !== child) {\n        return SKIP\n      }\n\n      if (\n        (child.tagName === 'th' || child.tagName === 'td') &&\n        child.properties\n      ) {\n        if (!info.align[cellIndex]) {\n          const value = String(child.properties.align || '') || null\n\n          if (\n            value === 'center' ||\n            value === 'left' ||\n            value === 'right' ||\n            value === null\n          ) {\n            info.align[cellIndex] = value\n          }\n        }\n\n        // If there is a `th` in the first row, assume there is a header row.\n        if (info.headless && rowIndex < 2 && child.tagName === 'th') {\n          info.headless = false\n        }\n\n        cellIndex++\n      }\n      // If there is a `thead`, assume there is a header row.\n      else if (child.tagName === 'thead') {\n        info.headless = false\n      } else if (child.tagName === 'tr') {\n        rowIndex++\n        cellIndex = 0\n      }\n    }\n  })\n\n  return info\n}\n\n/**\n * @returns {RowContent}\n */\nfunction createCell() {\n  return {type: 'tableCell', children: []}\n}\n\n/**\n * @returns {TableContent}\n */\nfunction createRow() {\n  return {type: 'tableRow', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Parents} from 'hast'\n */\n\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\n/**\n * Default handlers for nodes.\n *\n * Each key is a node type, each value is a `NodeHandler`.\n */\nexport const nodeHandlers = {\n  comment,\n  doctype: ignore,\n  root,\n  text\n}\n\n/**\n * Default handlers for elements.\n *\n * Each key is an element name, each value is a `Handler`.\n */\nexport const handlers = {\n  // Ignore:\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  // Use children:\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  // Use children as flow.\n  address: flow,\n  article: flow,\n  aside: flow,\n  body: flow,\n  center: flow,\n  div: flow,\n  fieldset: flow,\n  figcaption: flow,\n  figure: flow,\n  form: flow,\n  footer: flow,\n  header: flow,\n  hgroup: flow,\n  html: flow,\n  legend: flow,\n  main: flow,\n  multicol: flow,\n  nav: flow,\n  picture: flow,\n  section: flow,\n\n  // Handle.\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction all(state, node) {\n  return state.all(node)\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction flow(state, node) {\n  return state.toFlow(state.all(node))\n}\n\n/**\n * @returns {undefined}\n */\nfunction ignore() {}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Comment} from 'hast'\n * @import {Html} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Comment>} node\n *   hast element to transform.\n * @returns {Html}\n *   mdast node.\n */\nexport function comment(state, node) {\n  /** @type {Html} */\n  const result = {\n    type: 'html',\n    value: '<!--' + node.value + '-->'\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n */\n\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastRoot>} node\n *   hast root to transform.\n * @returns {MdastRoot}\n *   mdast node.\n */\nexport function root(state, node) {\n  let children = state.all(node)\n\n  if (state.options.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  /** @type {MdastRoot} */\n  const result = {type: 'root', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Text as HastText} from 'hast'\n * @import {Text as MdastText} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastText>} node\n *   hast element to transform.\n * @returns {MdastText}\n *   mdast node.\n */\nexport function text(state, node) {\n  /** @type {MdastText} */\n  const result = {type: 'text', value: node.value}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link}\n *   mdast node.\n */\nexport function a(state, node) {\n  const properties = node.properties || {}\n  // Allow potentially â€œinvalidâ€ nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    url: state.resolve(String(properties.href || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {undefined}\n *   Nothing.\n */\nexport function base(state, node) {\n  if (!state.baseFound) {\n    state.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || undefined\n    state.baseFound = true\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Blockquote} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Blockquote}\n *   mdast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Blockquote} */\n  const result = {type: 'blockquote', children: state.toFlow(state.all(node))}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Break} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Break}\n *   mdast node.\n */\nexport function br(state, node) {\n  /** @type {Break} */\n  const result = {type: 'break'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ThematicBreak} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ThematicBreak}\n *   mdast node.\n */\nexport function hr(state, node) {\n  /** @type {ThematicBreak} */\n  const result = {type: 'thematicBreak'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link | undefined}\n *   mdast node.\n */\nexport function iframe(state, node) {\n  const properties = node.properties || {}\n  const source = String(properties.src || '')\n  const title = String(properties.title || '')\n\n  // Only create a link if there is a title.\n  // We canâ€™t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (source && title) {\n    /** @type {Link} */\n    const result = {\n      type: 'link',\n      title: null,\n      url: state.resolve(source),\n      children: [{type: 'text', value: title}]\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, Text} from 'mdast'\n * @import {Options} from '../util/find-selected-options.js'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\nconst defaultChecked = '[x]'\nconst defaultUnchecked = '[ ]'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<Link | Text> | Image | Text | undefined}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function input(state, node) {\n  const properties = node.properties || {}\n  const value = String(properties.value || properties.placeholder || '')\n\n  if (\n    properties.disabled ||\n    properties.type === 'hidden' ||\n    properties.type === 'file'\n  ) {\n    return\n  }\n\n  if (properties.type === 'checkbox' || properties.type === 'radio') {\n    /** @type {Text} */\n    const result = {\n      type: 'text',\n      value: properties.checked\n        ? state.options.checked || defaultChecked\n        : state.options.unchecked || defaultUnchecked\n    }\n    state.patch(node, result)\n    return result\n  }\n\n  if (properties.type === 'image') {\n    const alt = properties.alt || value\n\n    if (alt) {\n      /** @type {Image} */\n      const result = {\n        type: 'image',\n        url: state.resolve(String(properties.src || '') || null),\n        title: String(properties.title || '') || null,\n        alt: String(alt)\n      }\n      state.patch(node, result)\n      return result\n    }\n\n    return\n  }\n\n  /** @type {Options} */\n  let values = []\n\n  if (value) {\n    values = [[value, undefined]]\n  } else if (\n    // `list` is not supported on these types:\n    properties.type !== 'button' &&\n    properties.type !== 'file' &&\n    properties.type !== 'password' &&\n    properties.type !== 'reset' &&\n    properties.type !== 'submit' &&\n    properties.list\n  ) {\n    const list = String(properties.list)\n    const datalist = state.elementById.get(list)\n\n    if (datalist && datalist.tagName === 'datalist') {\n      values = findSelectedOptions(datalist, properties)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (properties.type === 'password') {\n    // Passwords donâ€™t support `list`.\n    values[0] = ['â€¢'.repeat(values[0][0].length), undefined]\n  }\n\n  if (properties.type === 'email' || properties.type === 'url') {\n    /** @type {Array<Link | Text>} */\n    const results = []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = state.resolve(values[index][0])\n      /** @type {Link} */\n      const result = {\n        type: 'link',\n        title: null,\n        url: properties.type === 'email' ? 'mailto:' + value : value,\n        children: [{type: 'text', value: values[index][1] || value}]\n      }\n\n      results.push(result)\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  /** @type {Array<string>} */\n  const texts = []\n  let index = -1\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  /** @type {Text} */\n  const result = {type: 'text', value: texts.join(', ')}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text | undefined}\n *   mdast node.\n */\nexport function select(state, node) {\n  const values = findSelectedOptions(node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < values.length) {\n    const value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    /** @type {Text} */\n    const result = {type: 'text', value: results.join(', ')}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function textarea(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function wbr(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: '\\u200B'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {\n *   BlockContent as MdastBlockContent,\n *   DefinitionContent as MdastDefinitionContent,\n *   Nodes as MdastNodes,\n *   Parents as MdastParents,\n *   RootContent as MdastRootContent\n * } from 'mdast'\n */\n\n/**\n * @typedef {MdastBlockContent | MdastDefinitionContent} MdastFlowContent\n */\n\n/**\n * @callback All\n *   Transform the children of a hast parent to mdast.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n *\n * @callback Handle\n *   Handle a particular element.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Element} element\n *   Element to transform.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback NodeHandle\n *   Handle a particular node.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {any} node\n *   Node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback One\n *   Transform a hast node to mdast.\n * @param {Nodes} node\n *   Expected hast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [checked='[x]']\n *   Value to use for a checked checkbox or radio input (default: `'[x]'`)\n * @property {boolean | null | undefined} [document]\n *   Whether the given tree represents a complete document (optional).\n *\n *   Applies when the `tree` is a `root` node.\n *   When the tree represents a complete document, then things are wrapped in\n *   paragraphs when needed, and otherwise theyâ€™re left as-is.\n *   The default checks for whether thereâ€™s mixed content: some phrasing nodes\n *   *and* some non-phrasing nodes.\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers]\n *   Object mapping tag names to functions handling the corresponding elements\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {boolean | null | undefined} [newlines=false]\n *   Keep line endings when collapsing whitespace (default: `false`).\n *\n *   The default collapses to a single space.\n * @property {Record<string, NodeHandle | null | undefined> | null | undefined} [nodeHandlers]\n *   Object mapping node types to functions handling the corresponding nodes\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {Array<string> | null | undefined} [quotes=['\"']]\n *   List of quotes to use (default: `['\"']`).\n *\n *   Each value can be one or two characters.\n *   When two, the first character determines the opening quote and the second\n *   the closing quote at that level.\n *   When one, both the opening and closing quote are that character.\n *\n *   The order in which the preferred quotes appear determines which quotes to\n *   use at which level of nesting.\n *   So, to prefer `â€˜â€™` at the first level of nesting, and `â€œâ€` at the second,\n *   pass `['â€˜â€™', 'â€œâ€']`.\n *   If `<q>`s are nested deeper than the given amount of quotes, the markers\n *   wrap around: a third level of nesting when using `['Â«Â»', 'â€¹â€º']` should\n *   have double guillemets, a fourth single, a fifth double again, etc.\n * @property {string | null | undefined} [unchecked='[ ]']\n *   Value to use for an unchecked checkbox or radio input (default: `'[ ]'`).\n *\n * @callback Patch\n *   Copy a nodeâ€™s positional info.\n * @param {Nodes} from\n *   hast node to copy from.\n * @param {MdastNodes} to\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback Resolve\n *   Resolve a URL relative to a base.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {All} all\n *   Transform the children of a hast parent to mdast.\n * @property {boolean} baseFound\n *   Whether a `<base>` element was seen.\n * @property {Map<string, Element>} elementById\n *   Elements by their `id`.\n * @property {string | undefined} frozenBaseUrl\n *   `href` of `<base>`, if any.\n * @property {Record<string, Handle>} handlers\n *   Applied element handlers.\n * @property {boolean} inTable\n *   Whether weâ€™re in a table.\n * @property {Record<string, NodeHandle>} nodeHandlers\n *   Applied node handlers.\n * @property {One} one\n *   Transform a hast node to mdast.\n * @property {Options} options\n *   User configuration.\n * @property {Patch} patch\n *   Copy a nodeâ€™s positional info.\n * @property {number} qNesting\n *   Non-negative finite integer representing how deep weâ€™re in `<q>`s.\n * @property {Resolve} resolve\n *   Resolve a URL relative to a base.\n * @property {ToFlow} toFlow\n *   Transform a list of mdast nodes to flow.\n * @property {<ChildType extends MdastNodes, ParentType extends MdastParents & {'children': Array<ChildType>}>(nodes: Array<MdastRootContent>, build: (() => ParentType)) => Array<ParentType>} toSpecificContent\n *   Turn arbitrary content into a list of a particular node type.\n *\n *   This is useful for example for lists, which must have list items as\n *   content.\n *   in this example, when non-items are found, they will be queued, and\n *   inserted into an adjacent item.\n *   When no actual items exist, one will be made with `build`.\n *\n * @callback ToFlow\n *   Transform a list of mdast nodes to flow.\n * @param {Array<MdastRootContent>} nodes\n *   mdast nodes.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\n\nimport {position} from 'unist-util-position'\nimport {handlers, nodeHandlers} from './handlers/index.js'\nimport {wrap} from './util/wrap.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a state.\n *\n * @param {Readonly<Options>} options\n *   User configuration.\n * @returns {State}\n *   State.\n */\nexport function createState(options) {\n  return {\n    all,\n    baseFound: false,\n    elementById: new Map(),\n    frozenBaseUrl: undefined,\n    handlers: {...handlers, ...options.handlers},\n    inTable: false,\n    nodeHandlers: {...nodeHandlers, ...options.nodeHandlers},\n    one,\n    options,\n    patch,\n    qNesting: 0,\n    resolve,\n    toFlow,\n    toSpecificContent\n  }\n}\n\n/**\n * Transform the children of a hast parent to mdast.\n *\n * You might want to combine this with `toFlow` or `toSpecificContent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  /** @type {Array<MdastRootContent>} */\n  const results = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Content -> content.\n    const result =\n      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */ (\n        this.one(child, parent)\n      )\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Transform a hast node to mdast.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n */\nfunction one(node, parent) {\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(this.handlers, node.tagName)) {\n      return this.handlers[node.tagName](this, node, parent) || undefined\n    }\n  } else if (own.call(this.nodeHandlers, node.type)) {\n    return this.nodeHandlers[node.type](this, node, parent) || undefined\n  }\n\n  // Unknown literal.\n  if ('value' in node && typeof node.value === 'string') {\n    /** @type {MdastRootContent} */\n    const result = {type: 'text', value: node.value}\n    this.patch(node, result)\n    return result\n  }\n\n  // Unknown parent.\n  if ('children' in node) {\n    return this.all(node)\n  }\n}\n\n/**\n * Copy a nodeâ€™s positional info.\n *\n * @param {Nodes} origin\n *   hast node to copy from.\n * @param {MdastNodes} node\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(origin, node) {\n  if (origin.position) node.position = position(origin)\n}\n\n/**\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n */\nfunction resolve(url) {\n  const base = this.frozenBaseUrl\n\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (base) {\n    return String(new URL(url, base))\n  }\n\n  return url\n}\n\n/**\n * Transform a list of mdast nodes to flow.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Array<MdastRootContent>} nodes\n *   Parent.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\nfunction toFlow(nodes) {\n  return wrap(nodes)\n}\n\n/**\n * Turn arbitrary content into a particular node type.\n *\n * This is useful for example for lists, which must have list items as content.\n * in this example, when non-items are found, they will be queued, and\n * inserted into an adjacent item.\n * When no actual items exist, one will be made with `build`.\n *\n * @template {MdastNodes} ChildType\n *   Node type of children.\n * @template {MdastParents & {'children': Array<ChildType>}} ParentType\n *   Node type of parent.\n * @param {Array<MdastRootContent>} nodes\n *   Nodes, which are either `ParentType`, or will be wrapped in one.\n * @param {() => ParentType} build\n *   Build a parent if needed (must have empty `children`).\n * @returns {Array<ParentType>}\n *   List of parents.\n */\nfunction toSpecificContent(nodes, build) {\n  const reference = build()\n  /** @type {Array<ParentType>} */\n  const results = []\n  /** @type {Array<ChildType>} */\n  let queue = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (expectedParent(node)) {\n      if (queue.length > 0) {\n        node.children.unshift(...queue)\n        queue = []\n      }\n\n      results.push(node)\n    } else {\n      // Assume `node` can be a child of `ParentType`.\n      // If we start checking nodes, weâ€™d run into problems with unknown nodes,\n      // which we do want to support.\n      const child = /** @type {ChildType} */ (node)\n      queue.push(child)\n    }\n  }\n\n  if (queue.length > 0) {\n    let node = results[results.length - 1]\n\n    if (!node) {\n      node = build()\n      results.push(node)\n    }\n\n    node.children.push(...queue)\n    queue = []\n  }\n\n  return results\n\n  /**\n   * @param {MdastNodes} node\n   * @returns {node is ParentType}\n   */\n  function expectedParent(node) {\n    return node.type === reference.type\n  }\n}\n","/**\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Nodes} from 'hast'\n * @import {Nodes as MdastNodes, RootContent as MdastRootContent} from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visit} from 'unist-util-visit'\nimport {createState} from './state.js'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Transform hast to mdast.\n *\n * @param {Readonly<Nodes>} tree\n *   hast tree to transform.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {MdastNodes}\n *   mdast tree.\n */\nexport function toMdast(tree, options) {\n  // We have to clone, cause weâ€™ll use `rehype-minify-whitespace` on the tree,\n  // which modifies.\n  const cleanTree = structuredClone(tree)\n  const settings = options || emptyOptions\n  const transformWhitespace = rehypeMinifyWhitespace({\n    newlines: settings.newlines === true\n  })\n  const state = createState(settings)\n  /** @type {MdastNodes} */\n  let mdast\n\n  // @ts-expect-error: fine to pass an arbitrary node.\n  transformWhitespace(cleanTree)\n\n  visit(cleanTree, function (node) {\n    if (node && node.type === 'element' && node.properties) {\n      const id = String(node.properties.id || '') || undefined\n\n      if (id && !state.elementById.has(id)) {\n        state.elementById.set(id, node)\n      }\n    }\n  })\n\n  const result = state.one(cleanTree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    // Assume content.\n    const children = /** @type {Array<MdastRootContent>} */ (result)\n    mdast = {type: 'root', children}\n  } else {\n    mdast = result\n  }\n\n  // Collapse text nodes, and fix whitespace.\n  //\n  // Most of this is taken care of by `rehype-minify-whitespace`, but\n  // weâ€™re generating some whitespace too, and some nodes are in the end\n  // ignored.\n  // So clean up.\n  visit(mdast, function (node, index, parent) {\n    if (node.type === 'text' && index !== undefined && parent) {\n      const previous = parent.children[index - 1]\n\n      if (previous && previous.type === node.type) {\n        previous.value += node.value\n        parent.children.splice(index, 1)\n\n        if (previous.position && node.position) {\n          previous.position.end = node.position.end\n        }\n\n        // Iterate over the previous node again, to handle its total value.\n        return index - 1\n      }\n\n      node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n      // We donâ€™t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n      // as there the whitespace matters.\n      if (\n        parent &&\n        (parent.type === 'heading' ||\n          parent.type === 'paragraph' ||\n          parent.type === 'root')\n      ) {\n        if (!index) {\n          node.value = node.value.replace(/^[\\t ]+/, '')\n        }\n\n        if (index === parent.children.length - 1) {\n          node.value = node.value.replace(/[\\t ]+$/, '')\n        }\n      }\n\n      if (!node.value) {\n        parent.children.splice(index, 1)\n        return index\n      }\n    }\n  })\n\n  return mdast\n}\n","/**\n * @import {Options} from 'hast-util-minify-whitespace'\n * @import {Root} from 'hast'\n */\n\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minifyWhitespace(tree, options)\n  }\n}\n","/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new mdast tree.\n *   Discards result.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the mdast tree.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {MdastRoot}\n *   Tree (mdast).\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/** @satisfies {Options} */\nconst defaults = {document: true}\n\n/**\n * Turn HTML into markdown.\n *\n * ###### Notes\n *\n * *   if a processor is given, runs the (remark) plugins used on it with an\n *     mdast tree, then discards the result (*bridge mode*)\n * *   otherwise, returns an mdast tree, the plugins used after `rehypeRemark`\n *     are remark plugins (*mutate mode*)\n *\n * > ðŸ‘‰ **Note**: Itâ€™s highly unlikely that you want to pass a `processor`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Options | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Options | Processor | null | undefined} [destination]\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Options | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Options | null | undefined} [options]\n *   When a processor was given, configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function rehypeRemark(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      const mdastTree = toMdast(tree, {...defaults, ...options})\n      await destination.run(mdastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree) {\n    return /** @type {MdastRoot} */ (\n      toMdast(tree, {...defaults, ...destination})\n    )\n  }\n}\n"],"names":["env","self","globalThis","deserialize","serialized","deserializer","$","_","as","out","index","set","unpair","has","get","type","value","arr","push","object","key","Date","source","flags","RegExp","map","Map","Set","add","name","message","BigInt","Object","Uint8Array","buffer","DataView","EMPTY","toString","keys","typeOf","asString","call","slice","includes","shouldSkip","_ref","TYPE","serialize","json","lossy","arguments","length","undefined","serializer","strict","pair","entry","TypeError","spread","valueOf","toJSON","entries","toISOString","structuredClone","any","options","emptyOptions","settings","one","includeImageAlt","includeHtml","Boolean","node","alt","all","children","Array","isArray","values","result","join","phrasing","convert","pointEnd","point","pointStart","position","line","column","offset","start","end","findAfter","parent","test","is","Error","Number","POSITIVE_INFINITY","indexOf","searchLineFeeds","searchTabOrSpaces","br","convertElement","cell","tagName","p","row","notRendered","properties","hidden","open","blockOrCaption","toText","tree","options_","block","whitespace","inferWhitespace","breakBefore","breakAfter","results","collectText","renderedTextCollection","count","repeat","info","prefix","suffix","items","concat","unshift","collectElement","String","collectPreText","lines","lastIndex","match","exec","trimAndCollapseSpacesAndTabs","replace","charCodeAt","wrap","noWrap","trimTrailingLines","input","code","codePointAt","state","classList","lang","child","className","meta","patch","del","listItemsSpread","handle","nodes","listItems","toSpecificContent","create","ordered","checked","em","dropSurroundingBreaks","heading","depth","charAt","img","url","resolve","src","title","inlineCode","findSelectedOptions","explicitProperties","selectedOptions","findOptions","size","Math","min","parseInt","multiple","option","selected","list","max","content","label","disabled","li","rest","checkbox","extractLeadingCheckbox","spreadout","toFlow","seenFlow","head","_objectSpread","restHead","wrapNeeded","runs","every","d","split","newParent","cloneWithoutChildren","newChild","onphrasing","onnonphrasing","flattened","flatten","queue","data","hName","hastPhrasing","mdastPhrasing","media","poster","linkInFallbackContent","fragment","visit","EXIT","image","defaultQuotes","strong","tableCell","rowSpan","colSpan","hastUtilToMdastTemporaryRowSpan","hastUtilToMdastTemporaryColSpan","createCell","createRow","nodeHandlers","comment","doctype","ignore","root","document","text","handlers","applet","area","basefont","bgsound","caption","col","colgroup","command","datalist","dialog","element","embed","frame","frameset","isindex","keygen","link","math","menu","menuitem","nextid","noembed","noframes","optgroup","param","script","shadow","spacer","style","svg","template","track","abbr","acronym","bdi","bdo","big","blink","button","canvas","cite","details","dfn","font","ins","marquee","meter","nobr","noscript","output","progress","rb","rbc","rp","rt","rtc","ruby","slot","small","span","sup","sub","tbody","tfoot","thead","time","address","flow","article","aside","body","center","div","fieldset","figcaption","figure","form","footer","header","hgroup","html","legend","main","multicol","nav","picture","section","a","href","audio","b","base","baseFound","frozenBaseUrl","blockquote","dir","dl","clean","groups","group","definitions","titles","previous","dt","dd","h1","h2","h3","h4","h5","h6","hr","i","iframe","placeholder","unchecked","elementById","texts","kbd","listing","mark","ol","plaintext","pre","q","quotes","qNesting","contents","quote","tail","close","s","samp","select","strike","summary","table","inTable","align","headless","rowIndex","cellIndex","SKIP","inspect","rows","cells","columns","otherRowIndex","colIndex","newCells","splice","alignIndex","td","textarea","th","tr","tt","u","ul","var","video","wbr","xmp","own","hasOwnProperty","this","dataMdast","origin","URL","build","reference","expectedParent","toMdast","cleanTree","transformWhitespace","minifyWhitespace","rehypeMinifyWhitespace","newlines","createState","mdast","id","defaults","rehypeRemark","destination","async","file","mdastTree","run"],"sourceRoot":""}