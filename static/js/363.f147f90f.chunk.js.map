{"version":3,"file":"static/js/363.f147f90f.chunk.js","mappings":"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","sources":["../node_modules/web-namespaces/index.js","../node_modules/hast-util-from-dom/lib/index.js","../node_modules/hast-util-parse-selector/lib/index.js","../node_modules/hastscript/lib/create-h.js","../node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","../node_modules/hastscript/lib/index.js"],"sourcesContent":["/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nexport const webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n","/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport {h, s} from 'hastscript'\nimport {webNamespaces} from 'web-namespaces'\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      const domNode = /** @type {Element} */ (node)\n      return element(domNode, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      const domNode = /** @type {Text} */ (node)\n      return text(domNode)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      const domNode = /** @type {Comment} */ (node)\n      return comment(domNode)\n    }\n\n    case 9 /* Document */: {\n      const domNode = /** @type {Document} */ (node)\n      return root(domNode, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      const domNode = /** @type {DocumentFragment} */ (node)\n      return root(domNode, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const x = space === webNamespaces.svg ? s : h\n  const tagName =\n    space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const properties = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return x(tagName, properties, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastRootContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n","/**\n * @import {Element, Nodes, RootContent, Root} from 'hast'\n * @import {Info, Schema} from 'property-information'\n */\n\n/**\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n */\n\n/**\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n */\n\n/**\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n */\n\n/**\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\n/**\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n */\n\n/**\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n */\n\n/**\n * @typedef {Record<string, PropertyValue | Style>} Properties\n *   Acceptable value for element properties.\n */\n\n/**\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n */\n\n/**\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n */\n\n/**\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n */\n\nimport {parse as parseCommas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as parseSpaces} from 'space-separated-tokens'\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node\n\n    if (selector === null || selector === undefined) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase()\n      const adjusted = adjust ? adjust.get(lower) : undefined\n      node.tagName = adjusted || lower\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value)\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child)\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; that’s the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = parseSpaces(value)\n    } else if (info.commaSeparated) {\n      result = parseCommas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = parseSpaces(parseCommas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value]\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(\n        /** @type {number | string} */ (\n          parsePrimitive(info, info.property, item)\n        )\n      )\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(\n      /** @type {Array<number | string> | number | string} */ (result)\n    )\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child)\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} styles\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = []\n\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '))\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {ReadonlyArray<string>} values\n *   List of properly cased keys.\n * @returns {Map<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map()\n\n  for (const value of values) {\n    result.set(value.toLowerCase(), value)\n  }\n\n  return result\n}\n","/**\n * List of case-sensitive SVG tag names.\n *\n * @type {ReadonlyArray<string>}\n */\nexport const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n"],"names":["webNamespaces","html","mathml","svg","xlink","xml","xmlns","fromDom","tree","options","transform","type","children","node","transformed","nodeType","space","namespaceURI","x","s","h","tagName","toLowerCase","content","attributes","getAttributeNames","properties","index","length","getAttribute","all","element","value","nodeValue","text","comment","root","one","afterTransform","nodes","childNodes","child","undefined","push","search","createH","schema","defaultTagName","caseSensitive","adjust","values","result","Map","set","createAdjustMap","selector","_len","arguments","Array","_key","unshift","props","previous","start","lastIndex","match","exec","subvalue","slice","id","isArray","className","parseSelector","lower","adjusted","get","record","keys","Object","key","list","item","isChild","entries","addProperty","addChild","info","find","Number","isNaN","spaceSeparated","parseSpaces","commaSeparated","parseCommas","commaOrSpaceSeparated","join","parsePrimitive","property","styles","style","String","finalResult","concat","Error","name","number","boolean","overloadedBoolean","normalize"],"sourceRoot":""}