{"version":3,"file":"static/js/378.94c58921.chunk.js","mappings":"0LAaO,SAASA,EAAsBC,EAAMC,GAC1C,IAAIC,GAAmB,EAcvB,OAVAC,EAAAA,EAAAA,IAAMH,EAAM,SAAUA,GACpB,GACG,UAAWA,GAAQ,WAAWI,KAAKJ,EAAKK,QAC3B,UAAdL,EAAKM,KAGL,OADAJ,GAAmB,EACZK,EAAAA,EAEX,GAEOC,UACHR,EAAKS,OAAST,EAAKS,MAAQ,KAC3BC,EAAAA,EAAAA,GAASV,KACRC,EAAMU,QAAQC,QAAUV,GAE/B,C,iBCzBO,SAASW,EAAyBC,GACvC,MAAO,MAAQA,EAAKJ,SAAS,IAAIK,cAAgB,GACnD,C,iCCgBA,SAASC,EAAIC,EAAMC,EAAGC,GACpB,MAAO,KAAOA,EAAQ,GAAK,KAAOF,CACpC,C,+BCdO,SAASG,EAAUF,EAAGG,EAAIpB,EAAOqB,GACtC,IAAIC,GAAS,EAEb,OAASA,EAAQtB,EAAMuB,OAAOC,QAG5B,GACoC,OAAlCxB,EAAMuB,OAAOD,GAAOG,YACpBC,EAAAA,EAAAA,GAAe1B,EAAM2B,MAAO3B,EAAMuB,OAAOD,IAEzC,MAAO,QAAQnB,KAAKkB,EAAKO,QAAU,GAAK,IAI5C,MAAO,MACT,C,4BC2CA,SAASb,EAAIC,EAAMC,EAAGC,GACpB,OAAQA,EAAQ,GAAK,QAAUF,CACjC,CClEO,SAASa,EAAW7B,GACzB,MAAM8B,EAAS9B,EAAMU,QAAQqB,OAAS,IAEtC,GAAe,MAAXD,GAA6B,MAAXA,EACpB,MAAM,IAAIE,MACR,gCACEF,EACA,gDAIN,OAAOA,CACT,C,wBCoBO,SAASG,EAAWC,EAASC,EAAQL,GAC1C,MAAMM,GAAcC,EAAAA,EAAAA,GAAkBH,GAChCI,GAAaD,EAAAA,EAAAA,GAAkBF,GAGrC,YAAoBI,IAAhBH,OACoBG,IAAfD,EAIQ,MAAXR,EACE,CAACK,QAAQ,EAAMD,SAAS,GACxB,CAACC,QAAQ,EAAOD,SAAS,GACZ,IAAfI,EAEE,CAACH,QAAQ,EAAMD,SAAS,GAExB,CAACC,QAAQ,EAAOD,SAAS,GAIb,IAAhBE,OACoBG,IAAfD,EAEH,CAACH,QAAQ,EAAOD,SAAS,GACV,IAAfI,EAEE,CAACH,QAAQ,EAAMD,SAAS,GAExB,CAACC,QAAQ,EAAOD,SAAS,QAIXK,IAAfD,EAEH,CAACH,QAAQ,EAAOD,SAAS,GACV,IAAfI,EAEE,CAACH,QAAQ,EAAMD,SAAS,GAExB,CAACC,QAAQ,EAAOD,SAAS,EACjC,CC/DO,SAASM,EAASzC,EAAMkB,EAAGjB,EAAOqB,GACvC,MAAMS,ECXD,SAAuB9B,GAC5B,MAAM8B,EAAS9B,EAAMU,QAAQ8B,UAAY,IAEzC,GAAe,MAAXV,GAA6B,MAAXA,EACpB,MAAM,IAAIE,MACR,mCACEF,EACA,kDAIN,OAAOA,CACT,CDDiBW,CAAczC,GACvB0C,EAAO1C,EAAM2C,MAAM,YACnBC,EAAU5C,EAAM6C,cAAcxB,GAC9BO,EAASgB,EAAQE,KAAKhB,GAE5B,IAAIiB,EAAUH,EAAQE,KACpB9C,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CAC1BC,MAAOpB,EACPF,UACGgB,EAAQO,aAGf,MAAMC,EAAcL,EAAQM,WAAW,GACjCC,EAAOrB,EACXZ,EAAKO,OAAOyB,WAAWhC,EAAKO,OAAOJ,OAAS,GAC5C4B,EACAtB,GAGEwB,EAAKnB,SACPY,GAAUnC,EAAAA,EAAAA,GAAyBwC,GAAeL,EAAQQ,MAAM,IAGlE,MAAMC,EAAcT,EAAQM,WAAWN,EAAQvB,OAAS,GAClDiC,EAAQxB,EAAWZ,EAAK6B,MAAMG,WAAW,GAAIG,EAAa1B,GAE5D2B,EAAMtB,SACRY,EAAUA,EAAQQ,MAAM,GAAI,IAAK3C,EAAAA,EAAAA,GAAyB4C,IAG5D,MAAMN,EAAQN,EAAQE,KAAKhB,GAQ3B,OANAY,IAEA1C,EAAM0D,+BAAiC,CACrCR,MAAOO,EAAMvB,QACbN,OAAQ0B,EAAKpB,SAERN,EAASmB,EAAUG,CAC5B,CAjDAV,EAASmB,KAyDT,SAAsB1C,EAAGG,EAAIpB,GAC3B,OAAOA,EAAMU,QAAQ8B,UAAY,GACnC,E,cE1DO,SAASoB,EAAK7D,GACnB,OAAOA,EAAKK,OAAS,EACvB,CCIO,SAASyD,EAAM9D,EAAMkB,EAAGjB,EAAOqB,GACpC,MAAMU,EAAQF,EAAW7B,GACnB8D,EAAmB,MAAV/B,EAAgB,QAAU,aACnCW,EAAO1C,EAAM2C,MAAM,SACzB,IAAIoB,EAAU/D,EAAM2C,MAAM,SAC1B,MAAMC,EAAU5C,EAAM6C,cAAcxB,GACpC,IAAIjB,EAAQwC,EAAQE,KAAK,MAmDzB,OAlDA1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKkE,KAAGhB,EAAAA,EAAAA,GAAA,CAAGrB,OAAQxB,EAAO8C,MAAO,KAAQN,EAAQO,aAE9D/C,GAASwC,EAAQE,KAAK,MAEtBiB,KAIIhE,EAAKmE,KAAOnE,EAAKoE,OAEnB,eAAehE,KAAKJ,EAAKmE,MAEzBH,EAAU/D,EAAM2C,MAAM,sBACtBvC,GAASwC,EAAQE,KAAK,KACtB1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CAAGrB,OAAQxB,EAAO8C,MAAO,KAAQN,EAAQO,aAE9D/C,GAASwC,EAAQE,KAAK,OAGtBiB,EAAU/D,EAAM2C,MAAM,kBACtBvC,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CACjBrB,OAAQxB,EACR8C,MAAOnD,EAAKoE,MAAQ,IAAM,KACvBvB,EAAQO,cAKjBY,IAEIhE,EAAKoE,QACPJ,EAAU/D,EAAM2C,MAAM,QAADyB,OAASN,IAC9B1D,GAASwC,EAAQE,KAAK,IAAMf,GAC5B3B,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKoE,OAAKlB,EAAAA,EAAAA,GAAA,CACnBrB,OAAQxB,EACR8C,MAAOnB,GACJa,EAAQO,aAGf/C,GAASwC,EAAQE,KAAKf,GACtBgC,KAGF3D,GAASwC,EAAQE,KAAK,KACtBJ,IAEOtC,CACT,CC5DO,SAASiE,EAAetE,EAAMkB,EAAGjB,EAAOqB,GAC7C,MAAMhB,EAAON,EAAKuE,cACZ5B,EAAO1C,EAAM2C,MAAM,kBACzB,IAAIoB,EAAU/D,EAAM2C,MAAM,SAC1B,MAAMC,EAAU5C,EAAM6C,cAAcxB,GACpC,IAAIjB,EAAQwC,EAAQE,KAAK,MACzB,MAAMmB,EAAMjE,EAAMgE,KAAKjE,EAAKkE,KAAGhB,EAAAA,EAAAA,GAAA,CAC7BrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,YAEb/C,GAASwC,EAAQE,KAAKmB,EAAM,MAE5BF,IAEA,MAAMpC,EAAQ3B,EAAM2B,MACpB3B,EAAM2B,MAAQ,GACdoC,EAAU/D,EAAM2C,MAAM,aAKtB,MAAM4B,EAAYvE,EAAMgE,KAAKhE,EAAMwE,cAAczE,IAAKkD,EAAAA,EAAAA,GAAA,CACpDrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,YAeb,OAbAY,IACA/D,EAAM2B,MAAQA,EACde,IAEa,SAATrC,GAAoB4D,GAAOA,IAAQM,EAEnB,aAATlE,EAETD,EAAQA,EAAMmD,MAAM,GAAI,GAExBnD,GAASwC,EAAQE,KAAK,KALtB1C,GAASwC,EAAQE,KAAKyB,EAAY,KAQ7BnE,CACT,CC1CO,SAASqE,EAAW1E,EAAMkB,EAAGjB,GAClC,IAAII,EAAQL,EAAKK,OAAS,GACtBsE,EAAW,IACXpD,GAAS,EAKb,KAAO,IAAIqD,OAAO,WAAaD,EAAW,YAAYvE,KAAKC,IACzDsE,GAAY,IAmBd,IAbE,WAAWvE,KAAKC,KACd,WAAWD,KAAKC,IAAU,WAAWD,KAAKC,IAAW,QAAQD,KAAKC,MAEpEA,EAAQ,IAAMA,EAAQ,OAUfkB,EAAQtB,EAAMuB,OAAOC,QAAQ,CACpC,MAAMoD,EAAU5E,EAAMuB,OAAOD,GACvBuD,EAAa7E,EAAM8E,eAAeF,GAExC,IAAIG,EAKJ,GAAKH,EAAQI,QAEb,KAAQD,EAAQF,EAAWI,KAAK7E,IAAS,CACvC,IAAI8E,EAAWH,EAAMzD,MAIY,KAA/BlB,EAAMiD,WAAW6B,IACkB,KAAnC9E,EAAMiD,WAAW6B,EAAW,IAE5BA,IAGF9E,EAAQA,EAAMmD,MAAM,EAAG2B,GAAY,IAAM9E,EAAMmD,MAAMwB,EAAMzD,MAAQ,EACrE,CACF,CAEA,OAAOoD,EAAWtE,EAAQsE,CAC5B,CHhEAd,EAAKD,KAaL,WACE,MAAO,GACT,ECZAE,EAAMF,KAwEN,WACE,MAAO,GACT,EC5EAU,EAAeV,KAuDf,WACE,MAAO,GACT,ECzDAc,EAAWd,KAoEX,WACE,MAAO,GACT,E,cC/DO,SAASwB,EAAqBpF,EAAMC,GACzC,MAAMoF,GAAM3E,EAAAA,EAAAA,GAASV,GAErB,OAAOQ,SACJP,EAAMU,QAAQ2E,cAEbtF,EAAKmE,MAEJnE,EAAKoE,OAENpE,EAAKuF,UACoB,IAAzBvF,EAAKuF,SAAS9D,QACY,SAA1BzB,EAAKuF,SAAS,GAAGjF,OAEhB+E,IAAQrF,EAAKmE,KAAO,UAAYkB,IAAQrF,EAAKmE,MAE9C,oBAAoB/D,KAAKJ,EAAKmE,OAG7B,iBAAiB/D,KAAKJ,EAAKmE,KAElC,CCfO,SAASqB,EAAKxF,EAAMkB,EAAGjB,EAAOqB,GACnC,MAAMU,EAAQF,EAAW7B,GACnB8D,EAAmB,MAAV/B,EAAgB,QAAU,aACnCa,EAAU5C,EAAM6C,cAAcxB,GAEpC,IAAIqB,EAEAqB,EAEJ,GAAIoB,EAAqBpF,EAAMC,GAAQ,CAErC,MAAM2B,EAAQ3B,EAAM2B,MACpB3B,EAAM2B,MAAQ,GACde,EAAO1C,EAAM2C,MAAM,YACnB,IAAIvC,EAAQwC,EAAQE,KAAK,KAWzB,OAVA1C,GAASwC,EAAQE,KACf9C,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CAC1BrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,aAGf/C,GAASwC,EAAQE,KAAK,KACtBJ,IACA1C,EAAM2B,MAAQA,EACPvB,CACT,CAEAsC,EAAO1C,EAAM2C,MAAM,QACnBoB,EAAU/D,EAAM2C,MAAM,SACtB,IAAIvC,EAAQwC,EAAQE,KAAK,KAsDzB,OArDA1C,GAASwC,EAAQE,KACf9C,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CAC1BrB,OAAQxB,EACR8C,MAAO,MACJN,EAAQO,aAGf/C,GAASwC,EAAQE,KAAK,MACtBiB,KAIIhE,EAAKmE,KAAOnE,EAAKoE,OAEnB,eAAehE,KAAKJ,EAAKmE,MAEzBH,EAAU/D,EAAM2C,MAAM,sBACtBvC,GAASwC,EAAQE,KAAK,KACtB1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CAAGrB,OAAQxB,EAAO8C,MAAO,KAAQN,EAAQO,aAE9D/C,GAASwC,EAAQE,KAAK,OAGtBiB,EAAU/D,EAAM2C,MAAM,kBACtBvC,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CACjBrB,OAAQxB,EACR8C,MAAOnD,EAAKoE,MAAQ,IAAM,KACvBvB,EAAQO,cAKjBY,IAEIhE,EAAKoE,QACPJ,EAAU/D,EAAM2C,MAAM,QAADyB,OAASN,IAC9B1D,GAASwC,EAAQE,KAAK,IAAMf,GAC5B3B,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKoE,OAAKlB,EAAAA,EAAAA,GAAA,CACnBrB,OAAQxB,EACR8C,MAAOnB,GACJa,EAAQO,aAGf/C,GAASwC,EAAQE,KAAKf,GACtBgC,KAGF3D,GAASwC,EAAQE,KAAK,KAEtBJ,IACOtC,CACT,CCzFO,SAASoF,EAAczF,EAAMkB,EAAGjB,EAAOqB,GAC5C,MAAMhB,EAAON,EAAKuE,cACZ5B,EAAO1C,EAAM2C,MAAM,iBACzB,IAAIoB,EAAU/D,EAAM2C,MAAM,SAC1B,MAAMC,EAAU5C,EAAM6C,cAAcxB,GACpC,IAAIjB,EAAQwC,EAAQE,KAAK,KACzB,MAAM2C,EAAOzF,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CACvCrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,YAEb/C,GAASwC,EAAQE,KAAK2C,EAAO,MAE7B1B,IAEA,MAAMpC,EAAQ3B,EAAM2B,MACpB3B,EAAM2B,MAAQ,GACdoC,EAAU/D,EAAM2C,MAAM,aAKtB,MAAM4B,EAAYvE,EAAMgE,KAAKhE,EAAMwE,cAAczE,IAAKkD,EAAAA,EAAAA,GAAA,CACpDrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,YAeb,OAbAY,IACA/D,EAAM2B,MAAQA,EACde,IAEa,SAATrC,GAAoBoF,GAAQA,IAASlB,EAErB,aAATlE,EAETD,EAAQA,EAAMmD,MAAM,GAAI,GAExBnD,GAASwC,EAAQE,KAAK,KALtB1C,GAASwC,EAAQE,KAAKyB,EAAY,KAQ7BnE,CACT,CC/CO,SAASsF,EAAY1F,GAC1B,MAAM8B,EAAS9B,EAAMU,QAAQiF,QAAU,IAEvC,GAAe,MAAX7D,GAA6B,MAAXA,GAA6B,MAAXA,EACtC,MAAM,IAAIE,MACR,gCACEF,EACA,qDAIN,OAAOA,CACT,CCZO,SAAS8D,EAAU5F,GACxB,MAAM8B,EAAS9B,EAAMU,QAAQmF,MAAQ,IAErC,GAAe,MAAX/D,GAA6B,MAAXA,GAA6B,MAAXA,EACtC,MAAM,IAAIE,MACR,gCACEF,EACA,mDAIN,OAAOA,CACT,CHXAyD,EAAK5B,KAsGL,SAAkB5D,EAAMkB,EAAGjB,GACzB,OAAOmF,EAAqBpF,EAAMC,GAAS,IAAM,GACnD,EC5GAwF,EAAc7B,KAuDd,WACE,MAAO,GACT,E,cG5CO,SAASmC,EAAO/F,EAAMkB,EAAGjB,EAAOqB,GACrC,MAAMS,ECXD,SAAqB9B,GAC1B,MAAM8B,EAAS9B,EAAMU,QAAQoF,QAAU,IAEvC,GAAe,MAAXhE,GAA6B,MAAXA,EACpB,MAAM,IAAIE,MACR,iCACEF,EACA,gDAIN,OAAOA,CACT,CDDiBiE,CAAY/F,GACrB0C,EAAO1C,EAAM2C,MAAM,UACnBC,EAAU5C,EAAM6C,cAAcxB,GAC9BO,EAASgB,EAAQE,KAAKhB,EAASA,GAErC,IAAIiB,EAAUH,EAAQE,KACpB9C,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CAC1BC,MAAOpB,EACPF,UACGgB,EAAQO,aAGf,MAAMC,EAAcL,EAAQM,WAAW,GACjCC,EAAOrB,EACXZ,EAAKO,OAAOyB,WAAWhC,EAAKO,OAAOJ,OAAS,GAC5C4B,EACAtB,GAGEwB,EAAKnB,SACPY,GAAUnC,EAAAA,EAAAA,GAAyBwC,GAAeL,EAAQQ,MAAM,IAGlE,MAAMC,EAAcT,EAAQM,WAAWN,EAAQvB,OAAS,GAClDiC,EAAQxB,EAAWZ,EAAK6B,MAAMG,WAAW,GAAIG,EAAa1B,GAE5D2B,EAAMtB,SACRY,EAAUA,EAAQQ,MAAM,GAAI,IAAK3C,EAAAA,EAAAA,GAAyB4C,IAG5D,MAAMN,EAAQN,EAAQE,KAAKhB,EAASA,GAQpC,OANAY,IAEA1C,EAAM0D,+BAAiC,CACrCR,MAAOO,EAAMvB,QACbN,OAAQ0B,EAAKpB,SAERN,EAASmB,EAAUG,CAC5B,CAjDA4C,EAAOnC,KAyDP,SAAoB1C,EAAGG,EAAIpB,GACzB,OAAOA,EAAMU,QAAQoF,QAAU,GACjC,EE7CO,MAAME,EAAS,CACpBC,WlBZK,SAAoBlG,EAAMkB,EAAGjB,EAAOqB,GACzC,MAAMqB,EAAO1C,EAAM2C,MAAM,cACnBC,EAAU5C,EAAM6C,cAAcxB,GACpCuB,EAAQE,KAAK,MACbF,EAAQsD,MAAM,GACd,MAAM9F,EAAQJ,EAAMmG,YAClBnG,EAAMoG,cAAcrG,EAAM6C,EAAQO,WAClCpC,GAGF,OADA2B,IACOtC,CACT,EkBEEiG,MAAOlF,EACPN,KhBVK,SAAcd,EAAMkB,EAAGjB,EAAOqB,GACnC,MAAMS,EiBTD,SAAoB9B,GACzB,MAAM8B,EAAS9B,EAAMU,QAAQ4F,OAAS,IAEtC,GAAe,MAAXxE,GAA6B,MAAXA,EACpB,MAAM,IAAIE,MACR,+BACEF,EACA,kDAIN,OAAOA,CACT,CjBHiByE,CAAWvG,GACpBoF,EAAMrF,EAAKK,OAAS,GACpB0D,EAAoB,MAAXhC,EAAiB,cAAgB,QAEhD,IAAI0E,EAAAA,EAAAA,GAAqBzG,EAAMC,GAAQ,CACrC,MAAM0C,EAAO1C,EAAM2C,MAAM,gBACnBvC,EAAQJ,EAAMmG,YAAYf,EAAKrE,GAErC,OADA2B,IACOtC,CACT,CAEA,MAAMwC,EAAU5C,EAAM6C,cAAcxB,GAC9BqD,EAAW5C,EAAO2E,OAAOC,KAAKC,IkBnB/B,SAAuBvG,EAAOwG,GACnC,MAAMC,EAASC,OAAO1G,GACtB,IAAIkB,EAAQuF,EAAOE,QAAQH,GACvBI,EAAW1F,EACX2F,EAAQ,EACRN,EAAM,EAEV,GAAyB,kBAAdC,EACT,MAAM,IAAIM,UAAU,sBAGtB,MAAkB,IAAX5F,GACDA,IAAU0F,IACNC,EAAQN,IACZA,EAAMM,GAGRA,EAAQ,EAGVD,EAAW1F,EAAQsF,EAAUpF,OAC7BF,EAAQuF,EAAOE,QAAQH,EAAWI,GAGpC,OAAOL,CACT,ClBN0CQ,CAAc/B,EAAKtD,GAAU,EAAG,IAClEY,EAAO1C,EAAM2C,MAAM,cACzB,IAAIvC,EAAQwC,EAAQE,KAAK4B,GAEzB,GAAI3E,EAAKqH,KAAM,CACb,MAAMrD,EAAU/D,EAAM2C,MAAM,iBAADyB,OAAkBN,IAC7C1D,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKqH,MAAInE,EAAAA,EAAAA,GAAA,CAClBrB,OAAQxB,EACR8C,MAAO,IACPmE,OAAQ,CAAC,MACNzE,EAAQO,aAGfY,GACF,CAEA,GAAIhE,EAAKqH,MAAQrH,EAAKuH,KAAM,CAC1B,MAAMvD,EAAU/D,EAAM2C,MAAM,iBAADyB,OAAkBN,IAC7C1D,GAASwC,EAAQE,KAAK,KACtB1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKuH,MAAIrE,EAAAA,EAAAA,GAAA,CAClBrB,OAAQxB,EACR8C,MAAO,KACPmE,OAAQ,CAAC,MACNzE,EAAQO,aAGfY,GACF,CAUA,OARA3D,GAASwC,EAAQE,KAAK,MAElBsC,IACFhF,GAASwC,EAAQE,KAAKsC,EAAM,OAG9BhF,GAASwC,EAAQE,KAAK4B,GACtBhC,IACOtC,CACT,EgB1CEmH,WGbK,SAAoBxH,EAAMkB,EAAGjB,EAAOqB,GACzC,MAAMU,EAAQF,EAAW7B,GACnB8D,EAAmB,MAAV/B,EAAgB,QAAU,aACnCW,EAAO1C,EAAM2C,MAAM,cACzB,IAAIoB,EAAU/D,EAAM2C,MAAM,SAC1B,MAAMC,EAAU5C,EAAM6C,cAAcxB,GACpC,IAAIjB,EAAQwC,EAAQE,KAAK,KAsDzB,OArDA1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKhE,EAAMwE,cAAczE,IAAKkD,EAAAA,EAAAA,GAAA,CAClCrB,OAAQxB,EACR8C,MAAO,KACJN,EAAQO,aAGf/C,GAASwC,EAAQE,KAAK,OAEtBiB,KAIGhE,EAAKmE,KAEN,eAAe/D,KAAKJ,EAAKmE,MAEzBH,EAAU/D,EAAM2C,MAAM,sBACtBvC,GAASwC,EAAQE,KAAK,KACtB1C,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CAAGrB,OAAQxB,EAAO8C,MAAO,KAAQN,EAAQO,aAE9D/C,GAASwC,EAAQE,KAAK,OAGtBiB,EAAU/D,EAAM2C,MAAM,kBACtBvC,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKmE,KAAGjB,EAAAA,EAAAA,GAAA,CACjBrB,OAAQxB,EACR8C,MAAOnD,EAAKoE,MAAQ,IAAM,MACvBvB,EAAQO,cAKjBY,IAEIhE,EAAKoE,QACPJ,EAAU/D,EAAM2C,MAAM,QAADyB,OAASN,IAC9B1D,GAASwC,EAAQE,KAAK,IAAMf,GAC5B3B,GAASwC,EAAQE,KACf9C,EAAMgE,KAAKjE,EAAKoE,OAAKlB,EAAAA,EAAAA,GAAA,CACnBrB,OAAQxB,EACR8C,MAAOnB,GACJa,EAAQO,aAGf/C,GAASwC,EAAQE,KAAKf,GACtBgC,KAGFrB,IAEOtC,CACT,EH/CEoC,SAAQ,EACRrB,UAAS,EACTqG,QIfK,SAAiBzH,EAAMkB,EAAGjB,EAAOqB,GACtC,MAAMoG,EAAOf,KAAKC,IAAID,KAAKgB,IAAI,EAAG3H,EAAKS,OAAS,GAAI,GAC9CoC,EAAU5C,EAAM6C,cAAcxB,GAEpC,IAAIvB,EAAAA,EAAAA,GAAsBC,EAAMC,GAAQ,CACtC,MAAM0C,EAAO1C,EAAM2C,MAAM,iBACnBoB,EAAU/D,EAAM2C,MAAM,YACtBvC,EAAQJ,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACrCL,EAAQO,WAAS,IACpBvB,OAAQ,KACRsB,MAAO,QAKT,OAHAa,IACArB,IAGEtC,EACA,MACU,IAATqH,EAAa,IAAM,KAAKhB,OAEvBrG,EAAMoB,QAGHkF,KAAKC,IAAIvG,EAAMuH,YAAY,MAAOvH,EAAMuH,YAAY,OAAS,GAGtE,CAEA,MAAMjD,EAAW,IAAI+B,OAAOgB,GACtB/E,EAAO1C,EAAM2C,MAAM,cACnBoB,EAAU/D,EAAM2C,MAAM,YAM5BC,EAAQE,KAAK4B,EAAW,KAExB,IAAItE,EAAQJ,EAAMgD,kBAAkBjD,GAAIkD,EAAAA,EAAAA,GAAA,CACtCrB,OAAQ,KACRsB,MAAO,MACJN,EAAQO,YAiBb,MAdI,SAAShD,KAAKC,KAEhBA,GAAQQ,EAAAA,EAAAA,GAAyBR,EAAMiD,WAAW,IAAMjD,EAAMmD,MAAM,IAGtEnD,EAAQA,EAAQsE,EAAW,IAAMtE,EAAQsE,EAErC1E,EAAMU,QAAQkH,WAChBxH,GAAS,IAAMsE,GAGjBX,IACArB,IAEOtC,CACT,EJ3CEwD,KAAI,EACJC,MAAK,EACLQ,eAAc,EACdI,WAAU,EACVc,KAAI,EACJC,cAAa,EACbqC,KKpBK,SAAc9H,EAAM+H,EAAQ9H,EAAOqB,GACxC,MAAMqB,EAAO1C,EAAM2C,MAAM,QACnBoF,EAAgB/H,EAAM+H,cAE5B,IAAIpC,EAAS5F,EAAKiI,QCbb,SAA4BhI,GACjC,MAAM8B,EAAS9B,EAAMU,QAAQuH,eAAiB,IAE9C,GAAe,MAAXnG,GAA6B,MAAXA,EACpB,MAAM,IAAIE,MACR,gCACEF,EACA,sDAIN,OAAOA,CACT,CDC8BoG,CAAmBlI,GAAS0F,EAAY1F,GAEpE,MAAMmI,EAAcpI,EAAKiI,QACV,MAAXrC,EACE,IACA,IEhBD,SAA0B3F,GAC/B,MAAM2F,EAASD,EAAY1F,GACrBmI,EAAcnI,EAAMU,QAAQyH,YAElC,IAAKA,EACH,MAAkB,MAAXxC,EAAiB,IAAM,IAGhC,GAAoB,MAAhBwC,GAAuC,MAAhBA,GAAuC,MAAhBA,EAChD,MAAM,IAAInG,MACR,gCACEmG,EACA,0DAIN,GAAIA,IAAgBxC,EAClB,MAAM,IAAI3D,MACR,uBACE2D,EACA,0BACAwC,EACA,sBAIN,OAAOA,CACT,CFVMC,CAAiBpI,GACrB,IAAIqI,KACFP,IAAU9H,EAAMsI,iBAAiB3C,IAAW3F,EAAMsI,eAEpD,IAAKvI,EAAKiI,QAAS,CACjB,MAAMO,EAAgBxI,EAAKuF,SAAWvF,EAAKuF,SAAS,QAAK/C,EAqCzD,GAzBc,MAAXoD,GAA6B,MAAXA,IAEnB4C,GACEA,EAAcjD,UAAaiD,EAAcjD,SAAS,IAEZ,SAAxCtF,EAAM2B,MAAM3B,EAAM2B,MAAMH,OAAS,IACO,aAAxCxB,EAAM2B,MAAM3B,EAAM2B,MAAMH,OAAS,IACO,SAAxCxB,EAAM2B,MAAM3B,EAAM2B,MAAMH,OAAS,IACO,aAAxCxB,EAAM2B,MAAM3B,EAAM2B,MAAMH,OAAS,IAEiB,IAAlDxB,EAAMwI,WAAWxI,EAAMwI,WAAWhH,OAAS,IACO,IAAlDxB,EAAMwI,WAAWxI,EAAMwI,WAAWhH,OAAS,IACO,IAAlDxB,EAAMwI,WAAWxI,EAAMwI,WAAWhH,OAAS,KAE3C6G,GAAqB,GAWnBzC,EAAU5F,KAAW2F,GAAU4C,EAAe,CAChD,IAAIjH,GAAS,EAEb,OAASA,EAAQvB,EAAKuF,SAAS9D,QAAQ,CACrC,MAAMiH,EAAO1I,EAAKuF,SAAShE,GAE3B,GACEmH,GACc,aAAdA,EAAKpI,MACLoI,EAAKnD,UACLmD,EAAKnD,SAAS,IACY,kBAA1BmD,EAAKnD,SAAS,GAAGjF,KACjB,CACAgI,GAAqB,EACrB,KACF,CACF,CACF,CACF,CAEIA,IACF1C,EAASwC,GAGXnI,EAAM+H,cAAgBpC,EACtB,MAAMvF,EAAQJ,EAAMoG,cAAcrG,EAAMsB,GAIxC,OAHArB,EAAMsI,eAAiB3C,EACvB3F,EAAM+H,cAAgBA,EACtBrF,IACOtC,CACT,EL7DEsI,SQvBK,SAAkB3I,EAAM+H,EAAQ9H,EAAOqB,GAC5C,MAAMsH,ECRD,SAA6B3I,GAClC,MAAM4I,EAAQ5I,EAAMU,QAAQiI,gBAAkB,MAE9C,GAAc,QAAVC,GAA6B,QAAVA,GAA6B,UAAVA,EACxC,MAAM,IAAI5G,MACR,gCACE4G,EACA,qEAIN,OAAOA,CACT,CDJyBC,CAAoB7I,GAC3C,IAAI2F,EAAS3F,EAAM+H,eAAiBrC,EAAY1F,GAG5C8H,GAA0B,SAAhBA,EAAOzH,MAAmByH,EAAOE,UAC7CrC,GAC2B,kBAAjBmC,EAAOgB,OAAsBhB,EAAOgB,OAAS,EACjDhB,EAAOgB,MACP,KACmC,IAAtC9I,EAAMU,QAAQqI,oBACX,EACAjB,EAAOxC,SAASyB,QAAQhH,IAC5B4F,GAGJ,IAAIqD,EAAOrD,EAAOnE,OAAS,GAGN,QAAnBmH,GACoB,UAAnBA,IACGb,GAA0B,SAAhBA,EAAOzH,MAAmByH,EAAOmB,QAAWlJ,EAAKkJ,WAE/DD,EAA6B,EAAtBtC,KAAKwC,KAAKF,EAAO,IAG1B,MAAMpG,EAAU5C,EAAM6C,cAAcxB,GACpCuB,EAAQE,KAAK6C,EAAS,IAAIc,OAAOuC,EAAOrD,EAAOnE,SAC/CoB,EAAQsD,MAAM8C,GACd,MAAMtG,EAAO1C,EAAM2C,MAAM,YACnBvC,EAAQJ,EAAMmG,YAClBnG,EAAMoG,cAAcrG,EAAM6C,EAAQO,WAQpC,SAAanC,EAAMM,EAAOJ,GACxB,GAAII,EACF,OAAQJ,EAAQ,GAAK,IAAIuF,OAAOuC,IAAShI,EAG3C,OAAQE,EAAQyE,EAASA,EAAS,IAAIc,OAAOuC,EAAOrD,EAAOnE,SAAWR,CACxE,GATA,OAFA0B,IAEOtC,CAUT,ERtBE+I,UU3BK,SAAmBpJ,EAAMkB,EAAGjB,EAAOqB,GACxC,MAAMqB,EAAO1C,EAAM2C,MAAM,aACnBoB,EAAU/D,EAAM2C,MAAM,YACtBvC,EAAQJ,EAAMgD,kBAAkBjD,EAAMsB,GAG5C,OAFA0C,IACArB,IACOtC,CACT,EVqBEgJ,KW1BK,SAAcrJ,EAAMkB,EAAGjB,EAAOqB,GAOnC,OALoBtB,EAAKuF,SAAS+D,KAAK,SAAUC,GAC/C,OAAOC,EAAAA,EAAAA,GAASD,EAClB,GAEgCtJ,EAAMgD,kBAAoBhD,EAAMoG,eAC/CoD,KAAKxJ,EAAOD,EAAMsB,EACrC,EXmBEyE,OAAM,EACNL,KY9BK,SAAc1F,EAAMkB,EAAGjB,EAAOqB,GACnC,OAAOrB,EAAMgE,KAAKjE,EAAKK,MAAOiB,EAChC,EZ6BEoI,ca7BK,SAAuBxI,EAAGG,EAAIpB,GACnC,MAAMI,GACJwF,EAAU5F,IAAUA,EAAMU,QAAQgJ,WAAa,IAAM,KACrDjD,OCTG,SAA6BzG,GAClC,MAAM2J,EAAa3J,EAAMU,QAAQkJ,gBAAkB,EAEnD,GAAID,EAAa,EACf,MAAM,IAAI3H,MACR,2CACE2H,EACA,wDAIN,OAAOA,CACT,CDHWE,CAAoB7J,IAE7B,OAAOA,EAAMU,QAAQgJ,WAAatJ,EAAMmD,MAAM,GAAI,GAAKnD,CACzD,E,iBEVO,SAASoG,EAAqBzG,EAAMC,GACzC,OAAOO,SACoB,IAAzBP,EAAMU,QAAQoJ,QACZ/J,EAAKK,QAEJL,EAAKqH,MAEN,WAAWjH,KAAKJ,EAAKK,SAEpB,0CAA0CD,KAAKJ,EAAKK,OAE3D,C,sJCAO,MAAM2J,EAAaC,EAAW,YAcxBC,EAAoBD,EAAW,cAuB/BE,EAAaF,EAAW,uBAa9B,SAASG,EAAatJ,GAC3B,OAGW,OAATA,IAAkBA,EAAO,IAAe,MAATA,EAEnC,CAaO,MAAMuJ,EAAaJ,EAAW,MAoBxBK,EAAgBL,EAAW,cAe3BM,EAAmBN,EAAW,kBAiBpC,SAASO,EAAmB1J,GACjC,OAAgB,OAATA,GAAiBA,GAAQ,CAClC,CAWO,SAAS2J,EAA0B3J,GACxC,OAAgB,OAATA,IAAkBA,EAAO,GAAc,KAATA,EACvC,CAiBO,SAAS4J,EAAc5J,GAC5B,OAAiB,IAAVA,IAAyB,IAAVA,GAAwB,KAATA,CACvC,CAuBO,MAAM6J,EAAqBV,EAAW,slJAsBhCW,EAAoBX,EAAW,MAU5C,SAASA,EAAWY,GAClB,OAUA,SAAe/J,GACb,OAAgB,OAATA,GAAiBA,GAAQ,GAAK+J,EAAMzK,KAAK2G,OAAO+D,aAAahK,GACtE,CACF,C,iBC5OO,SAASa,EAAeC,EAAOiD,GACpC,OACEkG,EAAYnJ,EAAOiD,EAAQmG,aAAa,KACvCD,EAAYnJ,EAAOiD,EAAQoG,gBAAgB,EAEhD,CAQA,SAASF,EAAYnJ,EAAOkG,EAAMoD,GAKhC,GAJoB,kBAATpD,IACTA,EAAO,CAACA,KAGLA,GAAwB,IAAhBA,EAAKrG,OAChB,OAAOyJ,EAGT,IAAI3J,GAAS,EAEb,OAASA,EAAQuG,EAAKrG,QACpB,GAAIG,EAAMuJ,SAASrD,EAAKvG,IACtB,OAAO,EAIX,OAAO,CACT,C,gECrBO,SAASe,EAAkBxB,GAChC,OAAa,OAATA,IAAiB2J,EAAAA,EAAAA,IAA0B3J,KAAS8J,EAAAA,EAAAA,IAAkB9J,GACjE,GAEL6J,EAAAA,EAAAA,IAAmB7J,GACd,OADT,CAGF,C,kCCdA,MAAMsK,EAAe,CAAC,EAef,SAAS1K,EAASL,EAAOM,GAC9B,MAAM0K,EAAW1K,GAAWyK,EAQ5B,OAAOE,EAAIjL,EAN2B,mBAA7BgL,EAASE,iBACZF,EAASE,gBAGmB,mBAAzBF,EAASG,aAA4BH,EAASG,YAGzD,CAcA,SAASF,EAAIjL,EAAOkL,EAAiBC,GACnC,GAqDF,SAAcnL,GACZ,OAAOG,QAAQH,GAA0B,kBAAVA,EACjC,CAvDML,CAAKK,GAAQ,CACf,GAAI,UAAWA,EACb,MAAsB,SAAfA,EAAMC,MAAoBkL,EAAmBnL,EAAMA,MAAX,GAGjD,GAAIkL,GAAmB,QAASlL,GAASA,EAAM6D,IAC7C,OAAO7D,EAAM6D,IAGf,GAAI,aAAc7D,EAChB,OAAOoL,EAAIpL,EAAMkF,SAAUgG,EAAiBC,EAEhD,CAEA,OAAIE,MAAMC,QAAQtL,GACToL,EAAIpL,EAAOkL,EAAiBC,GAG9B,EACT,CAcA,SAASC,EAAIG,EAAQL,EAAiBC,GAEpC,MAAMK,EAAS,GACf,IAAItK,GAAS,EAEb,OAASA,EAAQqK,EAAOnK,QACtBoK,EAAOtK,GAAS+J,EAAIM,EAAOrK,GAAQgK,EAAiBC,GAGtD,OAAOK,EAAOC,KAAK,GACrB,C,kCC7EO,MAAMtC,GAGTuC,E,QAAAA,GAAQ,CACN,QACA,SACA,WAEA,WACA,oBACA,QACA,iBACA,aAEA,aACA,OACA,gBAEA,oBAEA,oBACA,SACA,OAEA,iB","sources":["../node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","../node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","../node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","../node_modules/mdast-util-to-markdown/lib/handle/break.js","../node_modules/mdast-util-to-markdown/lib/handle/code.js","../node_modules/mdast-util-to-markdown/lib/util/check-quote.js","../node_modules/mdast-util-to-markdown/lib/util/encode-info.js","../node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","../node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","../node_modules/mdast-util-to-markdown/lib/handle/html.js","../node_modules/mdast-util-to-markdown/lib/handle/image.js","../node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","../node_modules/mdast-util-to-markdown/lib/handle/link.js","../node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule.js","../node_modules/mdast-util-to-markdown/lib/handle/strong.js","../node_modules/mdast-util-to-markdown/lib/util/check-strong.js","../node_modules/mdast-util-to-markdown/lib/handle/index.js","../node_modules/mdast-util-to-markdown/lib/util/check-fence.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-to-markdown/lib/handle/definition.js","../node_modules/mdast-util-to-markdown/lib/handle/heading.js","../node_modules/mdast-util-to-markdown/lib/handle/list.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","../node_modules/mdast-util-to-markdown/lib/handle/root.js","../node_modules/mdast-util-to-markdown/lib/handle/text.js","../node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","../node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","../node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","../node_modules/micromark-util-character/index.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/micromark-util-classify-character/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/mdast-util-phrasing/lib/index.js"],"sourcesContent":["/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport { markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n    return 1;\n  }\n  if (unicodePunctuation(code)) {\n    return 2;\n  }\n}","/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * > 👉 **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n"],"names":["formatHeadingAsSetext","node","state","literalWithBreak","visit","test","value","type","EXIT","Boolean","depth","toString","options","setext","encodeCharacterReference","code","toUpperCase","map","line","_","blank","hardBreak","_1","info","index","unsafe","length","character","patternInScope","stack","before","checkQuote","marker","quote","Error","encodeInfo","outside","inside","outsideKind","classifyCharacter","insideKind","undefined","emphasis","checkEmphasis","exit","enter","tracker","createTracker","move","between","containerPhrasing","_objectSpread","after","current","betweenHead","charCodeAt","open","slice","betweenTail","close","attentionEncodeSurroundingInfo","peek","html","image","suffix","subexit","safe","alt","url","title","concat","imageReference","referenceType","reference","associationId","inlineCode","sequence","RegExp","pattern","expression","compilePattern","match","atBreak","exec","position","formatLinkAsAutolink","raw","resourceLink","children","link","linkReference","text","checkBullet","bullet","checkRule","rule","strong","checkStrong","handle","blockquote","shift","indentLines","containerFlow","break","fence","checkFence","formatCodeAsIndented","repeat","Math","max","substring","source","String","indexOf","expected","count","TypeError","longestStreak","lang","encode","meta","definition","heading","rank","min","lastIndexOf","closeAtx","list","parent","bulletCurrent","ordered","bulletOrdered","checkBulletOrdered","bulletOther","checkBulletOther","useDifferentMarker","bulletLastUsed","firstListItem","indexStack","item","listItem","listItemIndent","style","checkListItemIndent","start","incrementListMarker","size","spread","ceil","paragraph","root","some","d","phrasing","call","thematicBreak","ruleSpaces","repetition","ruleRepetition","checkRuleRepetition","fences","asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","unicodePunctuation","unicodeWhitespace","regex","fromCharCode","listInScope","inConstruct","notInConstruct","none","includes","emptyOptions","settings","one","includeImageAlt","includeHtml","all","Array","isArray","values","result","join","convert"],"sourceRoot":""}