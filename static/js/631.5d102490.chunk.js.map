{"version":3,"file":"static/js/631.5d102490.chunk.js","mappings":"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","sources":["../node_modules/vfile/lib/minpath.browser.js","../node_modules/vfile/lib/minproc.browser.js","../node_modules/vfile/lib/minurl.shared.js","../node_modules/vfile/lib/minurl.browser.js","../node_modules/vfile/lib/index.js","../node_modules/devlop/lib/default.js","../node_modules/vfile-message/lib/index.js","../node_modules/unist-util-stringify-position/lib/index.js"],"sourcesContent":["// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const minpath = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | null | undefined} [extname]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, extname) {\n  if (extname !== undefined && typeof extname !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (\n    extname === undefined ||\n    extname.length === 0 ||\n    extname.length > path.length\n  ) {\n    while (index--) {\n      if (path.codePointAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (extname === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extnameIndex = extname.length - 1\n\n  while (index--) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extnameIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.codePointAt(index) === extname.codePointAt(extnameIndex--)) {\n          if (extnameIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extnameIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.codePointAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.codePointAt(0) === 47 /* `/` */\n      ? '//'\n      : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.codePointAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.codePointAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.codePointAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.codePointAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.codePointAt(result.length - 1) !== 46 /* `.` */ ||\n          result.codePointAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexport const minproc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * Checks if a value has the shape of a WHATWG URL object.\n *\n * Using a symbol or instanceof would not be able to recognize URL objects\n * coming from other implementations (e.g. in Electron), so instead we are\n * checking some well known properties for a lack of a better test.\n *\n * We use `href` and `protocol` as they are the only properties that are\n * easy to retrieve and calculate due to the lazy nature of the getters.\n *\n * We check for auth attribute to distinguish legacy url instance with\n * WHATWG URL instance.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether it’s a URL.\n */\n// From: <https://github.com/nodejs/node/blob/6a3403c/lib/internal/url.js#L720>\nexport function isUrl(fileUrlOrPath) {\n  return Boolean(\n    fileUrlOrPath !== null &&\n      typeof fileUrlOrPath === 'object' &&\n      'href' in fileUrlOrPath &&\n      fileUrlOrPath.href &&\n      'protocol' in fileUrlOrPath &&\n      fileUrlOrPath.protocol &&\n      // @ts-expect-error: indexing is fine.\n      fileUrlOrPath.auth === undefined\n  )\n}\n","import {isUrl} from './minurl.shared.js'\n\nexport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/6a3403c/lib/internal/url.js>\n\n/**\n * @param {URL | string} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.codePointAt(index) === 37 /* `%` */ &&\n      pathname.codePointAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.codePointAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n","/**\n * @import {Node, Point, Position} from 'unist'\n * @import {Options as MessageOptions} from 'vfile-message'\n * @import {Compatible, Data, Map, Options, Value} from 'vfile'\n */\n\n/**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {VFileMessage} from 'vfile-message'\nimport {minpath} from '#minpath'\nimport {minproc} from '#minproc'\nimport {urlToPath, isUrl} from '#minurl'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n */\nconst order = /** @type {const} */ ([\n  'history',\n  'path',\n  'basename',\n  'stem',\n  'extname',\n  'dirname'\n])\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Uint8Array` — `{value: options}`\n   * *   `URL` — `{path: options}`\n   * *   `VFile` — shallow copies its data over to the new file\n   * *   `object` — all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else if (typeof value === 'string' || isUint8Array(value)) {\n      options = {value}\n    } else {\n      options = value\n    }\n\n    /* eslint-disable no-unused-expressions */\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    // Prevent calling `cwd` (which could be expensive) if it’s not needed;\n    // the empty string will be overridden in the next block.\n    this.cwd = 'cwd' in options ? '' : minproc.cwd()\n\n    /**\n     * Place to store custom info (default: `{}`).\n     *\n     * It’s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of file paths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const field = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        field in options &&\n        options[field] !== undefined &&\n        options[field] !== null\n      ) {\n        // @ts-expect-error: TS doesn’t understand basic reality.\n        this[field] = field === 'history' ? [...options[field]] : options[field]\n      }\n    }\n\n    /** @type {string} */\n    let field\n\n    // Set non-path related properties.\n    for (field in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(field)) {\n        // @ts-expect-error: fine to set other things.\n        this[field] = options[field]\n      }\n    }\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   *\n   * @returns {string | undefined}\n   *   Basename.\n   */\n  get basename() {\n    return typeof this.path === 'string'\n      ? minpath.basename(this.path)\n      : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} basename\n   *   Basename.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = minpath.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   *\n   * @returns {string | undefined}\n   *   Dirname.\n   */\n  get dirname() {\n    return typeof this.path === 'string'\n      ? minpath.dirname(this.path)\n      : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there’s no `path` yet.\n   *\n   * @param {string | undefined} dirname\n   *   Dirname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = minpath.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   *\n   * @returns {string | undefined}\n   *   Extname.\n   */\n  get extname() {\n    return typeof this.path === 'string'\n      ? minpath.extname(this.path)\n      : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there’s no `path` yet.\n   *\n   * @param {string | undefined} extname\n   *   Extname.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.codePointAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = minpath.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   *   Path.\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {URL | string} path\n   *   Path.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * @returns {string | undefined}\n   *   Stem.\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? minpath.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   *\n   * @param {string} stem\n   *   Stem.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = minpath.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  // Normal prototypal methods.\n  /**\n   * Create a fatal message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `true` (error; file not usable)\n   * and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > 🪦 **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {never}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Never.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n\n  /**\n   * Create an info message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `undefined` (info; change\n   * likely not needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > 🪦 **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(causeOrReason, optionsOrParentOrPlace, origin) {\n    // @ts-expect-error: the overloads are fine.\n    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin)\n\n    message.fatal = undefined\n\n    return message\n  }\n\n  /**\n   * Create a message for `reason` associated with the file.\n   *\n   * The `fatal` field of the message is set to `false` (warning; change may be\n   * needed) and the `file` field is set to the current file path.\n   * The message is added to the `messages` field on `file`.\n   *\n   * > 🪦 **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {MessageOptions | null | undefined} [options]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns {VFileMessage}\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(causeOrReason, optionsOrParentOrPlace, origin) {\n    const message = new VFileMessage(\n      // @ts-expect-error: the overloads are fine.\n      causeOrReason,\n      optionsOrParentOrPlace,\n      origin\n    )\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * > **Note**: which encodings are supported depends on the engine.\n   * > For info on Node.js, see:\n   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.\n   *\n   * @param {string | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it’s a `Uint8Array`\n   *   (default: `'utf-8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    if (this.value === undefined) {\n      return ''\n    }\n\n    if (typeof this.value === 'string') {\n      return this.value\n    }\n\n    const decoder = new TextDecoder(encoding || undefined)\n    return decoder.decode(this.value)\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {undefined}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(minpath.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + minpath.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'byteLength' in value &&\n      'byteOffset' in value\n  )\n}\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef Options\n *   Configuration.\n * @property {Array<Node> | null | undefined} [ancestors]\n *   Stack of (inclusive) ancestor nodes surrounding the message (optional).\n * @property {Error | null | undefined} [cause]\n *   Original error cause of the message (optional).\n * @property {Point | Position | null | undefined} [place]\n *   Place of message (optional).\n * @property {string | null | undefined} [ruleId]\n *   Category of message (optional, example: `'my-rule'`).\n * @property {string | null | undefined} [source]\n *   Namespace of who sent the message (optional, example: `'my-package'`).\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason`.\n   *\n   * > 🪦 **Note**: also has obsolete signatures.\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Options | null | undefined} [options]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {string} reason\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Node | NodeLike | null | undefined} parent\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {Point | Position | null | undefined} place\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @overload\n   * @param {Error | VFileMessage} cause\n   * @param {string | null | undefined} [origin]\n   * @returns\n   *\n   * @param {Error | VFileMessage | string} causeOrReason\n   *   Reason for message, should use markdown.\n   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]\n   *   Configuration (optional).\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // eslint-disable-next-line complexity\n  constructor(causeOrReason, optionsOrParentOrPlace, origin) {\n    super()\n\n    if (typeof optionsOrParentOrPlace === 'string') {\n      origin = optionsOrParentOrPlace\n      optionsOrParentOrPlace = undefined\n    }\n\n    /** @type {string} */\n    let reason = ''\n    /** @type {Options} */\n    let options = {}\n    let legacyCause = false\n\n    if (optionsOrParentOrPlace) {\n      // Point.\n      if (\n        'line' in optionsOrParentOrPlace &&\n        'column' in optionsOrParentOrPlace\n      ) {\n        options = {place: optionsOrParentOrPlace}\n      }\n      // Position.\n      else if (\n        'start' in optionsOrParentOrPlace &&\n        'end' in optionsOrParentOrPlace\n      ) {\n        options = {place: optionsOrParentOrPlace}\n      }\n      // Node.\n      else if ('type' in optionsOrParentOrPlace) {\n        options = {\n          ancestors: [optionsOrParentOrPlace],\n          place: optionsOrParentOrPlace.position\n        }\n      }\n      // Options.\n      else {\n        options = {...optionsOrParentOrPlace}\n      }\n    }\n\n    if (typeof causeOrReason === 'string') {\n      reason = causeOrReason\n    }\n    // Error.\n    else if (!options.cause && causeOrReason) {\n      legacyCause = true\n      reason = causeOrReason.message\n      options.cause = causeOrReason\n    }\n\n    if (!options.ruleId && !options.source && typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        options.ruleId = origin\n      } else {\n        options.source = origin.slice(0, index)\n        options.ruleId = origin.slice(index + 1)\n      }\n    }\n\n    if (!options.place && options.ancestors && options.ancestors) {\n      const parent = options.ancestors[options.ancestors.length - 1]\n\n      if (parent) {\n        options.place = parent.position\n      }\n    }\n\n    const start =\n      options.place && 'start' in options.place\n        ? options.place.start\n        : options.place\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Stack of ancestor nodes surrounding the message.\n     *\n     * @type {Array<Node> | undefined}\n     */\n    this.ancestors = options.ancestors || undefined\n\n    /**\n     * Original error cause of the message.\n     *\n     * @type {Error | undefined}\n     */\n    this.cause = options.cause || undefined\n\n    /**\n     * Starting column of message.\n     *\n     * @type {number | undefined}\n     */\n    this.column = start ? start.column : undefined\n\n    /**\n     * State of problem.\n     *\n     * * `true` — error, file not usable\n     * * `false` — warning, change may be needed\n     * * `undefined` — change likely not needed\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal = undefined\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | undefined}\n     */\n    this.file\n\n    // Field from `Error`.\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = reason\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | undefined}\n     */\n    this.line = start ? start.line : undefined\n\n    // Field from `Error`.\n    /**\n     * Serialized positional info of message.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(options.place) || '1:1'\n\n    /**\n     * Place of message.\n     *\n     * @type {Point | Position | undefined}\n     */\n    this.place = options.place || undefined\n\n    /**\n     * Reason for message, should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | undefined}\n     */\n    this.ruleId = options.ruleId || undefined\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | undefined}\n     */\n    this.source = options.source || undefined\n\n    // Field from `Error`.\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack =\n      legacyCause && options.cause && typeof options.cause.stack === 'string'\n        ? options.cause.stack\n        : ''\n\n    // The following fields are “well known”.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that’s being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | undefined}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | undefined}\n     */\n    this.expected\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | undefined}\n     */\n    this.note\n\n    /**\n     * Link to docs for the message.\n     *\n     * > 👉 **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | undefined}\n     */\n    this.url\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.column = undefined\nVFileMessage.prototype.line = undefined\nVFileMessage.prototype.ancestors = undefined\nVFileMessage.prototype.cause = undefined\nVFileMessage.prototype.fatal = undefined\nVFileMessage.prototype.place = undefined\nVFileMessage.prototype.ruleId = undefined\nVFileMessage.prototype.source = undefined\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Point | PointLike | Position | PositionLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n"],"names":["minpath","basename","path","extname","undefined","TypeError","assertPath","seenNonSlash","start","end","index","length","codePointAt","slice","firstNonSlashEnd","extnameIndex","dirname","unmatchedSlash","startPart","startDot","preDotState","code","join","joined","_len","arguments","segments","Array","_key","absolute","value","allowAboveRoot","lastSlashIndex","result","lastSegmentLength","lastSlash","dots","lastIndexOf","normalizeString","normalize","sep","JSON","stringify","minproc","cwd","isUrl","fileUrlOrPath","Boolean","href","protocol","auth","urlToPath","URL","error","url","hostname","pathname","third","decodeURIComponent","getPathFromURLPosix","order","VFile","constructor","options","isUint8Array","this","data","history","messages","map","stored","field","includes","assertNonEmpty","assertPart","Error","stem","push","fail","causeOrReason","optionsOrParentOrPlace","origin","message","fatal","info","VFileMessage","name","file","toString","encoding","TextDecoder","decode","part","ok","super","reason","legacyCause","place","ancestors","position","_objectSpread","cause","ruleId","source","indexOf","parent","column","line","stringifyPosition","stack","actual","expected","note","prototype","point","pos"],"sourceRoot":""}