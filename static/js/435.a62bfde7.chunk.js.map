{"version":3,"file":"static/js/435.a62bfde7.chunk.js","mappings":"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","sources":["../node_modules/@ungap/structured-clone/esm/types.js","../node_modules/@ungap/structured-clone/esm/deserialize.js","../node_modules/@ungap/structured-clone/esm/serialize.js","../node_modules/@ungap/structured-clone/esm/index.js","../node_modules/devlop/lib/default.js","../node_modules/micromark-util-character/index.js","../node_modules/unist-util-position/lib/index.js","../node_modules/micromark-util-sanitize-uri/index.js","../node_modules/mdast-util-to-hast/lib/footer.js","../node_modules/mdast-util-to-hast/lib/revert.js","../node_modules/mdast-util-to-hast/lib/handlers/list-item.js","../node_modules/trim-lines/index.js","../node_modules/mdast-util-to-hast/lib/handlers/index.js","../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","../node_modules/mdast-util-to-hast/lib/handlers/break.js","../node_modules/mdast-util-to-hast/lib/handlers/code.js","../node_modules/mdast-util-to-hast/lib/handlers/delete.js","../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","../node_modules/mdast-util-to-hast/lib/handlers/heading.js","../node_modules/mdast-util-to-hast/lib/handlers/html.js","../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","../node_modules/mdast-util-to-hast/lib/handlers/image.js","../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","../node_modules/mdast-util-to-hast/lib/handlers/link.js","../node_modules/mdast-util-to-hast/lib/handlers/list.js","../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","../node_modules/mdast-util-to-hast/lib/handlers/root.js","../node_modules/mdast-util-to-hast/lib/handlers/strong.js","../node_modules/mdast-util-to-hast/lib/handlers/table.js","../node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","../node_modules/mdast-util-to-hast/lib/handlers/table-row.js","../node_modules/mdast-util-to-hast/lib/handlers/text.js","../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","../node_modules/mdast-util-to-hast/lib/state.js","../node_modules/mdast-util-to-hast/lib/index.js","../node_modules/remark-rehype/lib/index.js"],"sourcesContent":["export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n","import {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} any a serializable value.\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\n * a transfer option (ignored when polyfilled) and/or non standard fields that\n * fallback to the polyfill if present.\n * @returns {Record[]}\n */\nexport default typeof structuredClone === \"function\" ?\n  /* c8 ignore start */\n  (any, options) => (\n    options && ('json' in options || 'lossy' in options) ?\n      deserialize(serialize(any, options)) : structuredClone(any)\n  ) :\n  (any, options) => deserialize(serialize(any, options));\n  /* c8 ignore stop */\n\nexport {deserialize, serialize};\n","export function deprecate(fn) {\n  return fn\n}\n\nexport function equal() {}\n\nexport function ok() {}\n\nexport function unreachable() {}\n","/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n","import { asciiAlphanumeric } from 'micromark-util-character';\nimport { encode } from 'micromark-util-encode';\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | null | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n  if (!protocol) {\n    return value;\n  }\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n  if (\n  // If there is no protocol, it’s relative.\n  colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign ||\n  // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n  return '';\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n    let replace = '';\n\n    // A correct percent encoded value.\n    if (code === 37 && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    }\n    // Astral.\n    else if (code > 55_295 && code < 57_344) {\n      const next = value.charCodeAt(index + 1);\n\n      // A correct surrogate pair.\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      }\n      // Lone surrogate.\n      else {\n        replace = \"\\uFFFD\";\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code);\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n  return result.join('') + value.slice(start);\n}","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @callback FootnoteBackContentTemplate\n *   Generate content for the backreference dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent> | ElementContent | string}\n *   Content for the backreference when linking back from definitions to their\n *   reference.\n *\n * @callback FootnoteBackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate the default content that GitHub uses on backreferences.\n *\n * @param {number} _\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent>}\n *   Content.\n */\nexport function defaultFootnoteBackContent(_, rereferenceIndex) {\n  /** @type {Array<ElementContent>} */\n  const result = [{type: 'text', value: '↩'}]\n\n  if (rereferenceIndex > 1) {\n    result.push({\n      type: 'element',\n      tagName: 'sup',\n      properties: {},\n      children: [{type: 'text', value: String(rereferenceIndex)}]\n    })\n  }\n\n  return result\n}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Label.\n */\nexport function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\n// eslint-disable-next-line complexity\nexport function footer(state) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const footnoteBackContent =\n    state.options.footnoteBackContent || defaultFootnoteBackContent\n  const footnoteBackLabel =\n    state.options.footnoteBackLabel || defaultFootnoteBackLabel\n  const footnoteLabel = state.options.footnoteLabel || 'Footnotes'\n  const footnoteLabelTagName = state.options.footnoteLabelTagName || 'h2'\n  const footnoteLabelProperties = state.options.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let referenceIndex = -1\n\n  while (++referenceIndex < state.footnoteOrder.length) {\n    const definition = state.footnoteById.get(\n      state.footnoteOrder[referenceIndex]\n    )\n\n    if (!definition) {\n      continue\n    }\n\n    const content = state.all(definition)\n    const id = String(definition.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let rereferenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n    const counts = state.footnoteCounts.get(id)\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (counts !== undefined && ++rereferenceIndex <= counts) {\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      let children =\n        typeof footnoteBackContent === 'string'\n          ? footnoteBackContent\n          : footnoteBackContent(referenceIndex, rereferenceIndex)\n\n      if (typeof children === 'string') {\n        children = {type: 'text', value: children}\n      }\n\n      backReferences.push({\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (rereferenceIndex > 1 ? '-' + rereferenceIndex : ''),\n          dataFootnoteBackref: '',\n          ariaLabel:\n            typeof footnoteBackLabel === 'string'\n              ? footnoteBackLabel\n              : footnoteBackLabel(referenceIndex, rereferenceIndex),\n          className: ['data-footnote-backref']\n        },\n        children: Array.isArray(children) ? children : [children]\n      })\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(definition, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: footnoteLabelTagName,\n        properties: {\n          ...structuredClone(footnoteLabelProperties),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Reference} Reference\n *\n * @typedef {import('./state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Extract<Nodes, Reference>} node\n *   Reference node (image, link).\n * @returns {Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return [{type: 'text', value: '![' + node.alt + suffix}]\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === null || spread === undefined\n    ? node.children.length > 1\n    : spread\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n *\n * @satisfies {import('../state.js').Handlers}\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  // @ts-expect-error: root is different, but hard to type.\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  return undefined\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  /** @type {Properties} */\n  const properties = {}\n\n  if (node.lang) {\n    properties.className = ['language-' + node.lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  let reuseCounter = state.footnoteCounts.get(id)\n\n  if (reuseCounter === undefined) {\n    reuseCounter = 0\n    state.footnoteOrder.push(id)\n    counter = state.footnoteOrder.length\n  } else {\n    counter = index + 1\n  }\n\n  reuseCounter += 1\n  state.footnoteCounts.set(id, reuseCounter)\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + clobberPrefix + 'fn-' + safeId,\n      id:\n        clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Html} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Element | Raw | undefined}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.options.allowDangerousHtml) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  return undefined\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(definition.url || ''), alt: node.alt}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(definition.url || '')}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Parents} HastParents\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastParents}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointEnd, pointStart} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start && end) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  // To do: option to use `style`?\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(cell, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastElement | HastText}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesn’t understand…\n        return result\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n","/**\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   hast tree.\n */\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, undefined)\n  const foot = footer(state)\n  /** @type {HastNodes} */\n  const result = Array.isArray(node)\n    ? {type: 'root', children: node}\n    : node || {type: 'root', children: []}\n\n  if (foot) {\n    // If there’s a footer, there were definitions, meaning block\n    // content.\n    // So `result` is a parent node.\n    assert('children' in result)\n    result.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  return result\n}\n","/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Options as ToHastOptions} from 'mdast-util-to-hast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<ToHastOptions, 'file'>} Options\n *\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new hast tree.\n *   Discards result.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the hast tree.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {HastRoot}\n *   Tree (hast).\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Turn markdown into HTML.\n *\n * ##### Notes\n *\n * ###### Signature\n *\n * * if a processor is given,\n *   runs the (rehype) plugins used on it with a hast tree,\n *   then discards the result (*bridge mode*)\n * * otherwise,\n *   returns a hast tree,\n *   the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n *\n * > 👉 **Note**:\n * > It’s highly unlikely that you want to pass a `processor`.\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most plugins ignore `raw` nodes but two notable ones don’t:\n *\n * * `rehype-stringify` also has an option `allowDangerousHtml` which will\n *   output the raw HTML.\n *   This is typically discouraged as noted by the option name but is useful if\n *   you completely trust authors\n * * `rehype-raw` can handle the raw embedded HTML strings by parsing them\n *   into standard hast nodes (`element`, `text`, etc);\n *   this is a heavy task as it needs a full HTML parser,\n *   but it is the only way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark,\n * which we follow by default.\n * They are supported by GitHub,\n * so footnotes can be enabled in markdown with `remark-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes,\n * which is hidden for sighted users but shown to assistive technology.\n * When your page is not in English,\n * you must define translated values.\n *\n * Back references use ARIA attributes,\n * but the section label itself uses a heading that is hidden with an\n * `sr-only` class.\n * To show it to sighted users,\n * define different attributes in `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem,\n * as it links footnote calls to footnote definitions on the page through `id`\n * attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * * when the node has a `value`\n *   (and doesn’t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n *   see later),\n *   create a hast `text` node\n * * otherwise,\n *   create a `<div>` element (which could be changed with `data.hName`),\n *   with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Readonly<Options> | null | undefined} [options]\n *   When a processor was given,\n *   configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */ (\n        toHast(tree, {file, ...options})\n      )\n      await destination.run(hastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    // To do: in the future, disallow ` || options` fallback.\n    // With `unified-engine`, `destination` can be `undefined` but\n    // `options` will be the file set.\n    // We should not pass that as `options`.\n    return /** @type {HastRoot} */ (\n      toHast(tree, {file, ...(destination || options)})\n    )\n  }\n}\n"],"names":["env","self","globalThis","deserialize","serialized","deserializer","$","_","as","out","index","set","unpair","has","get","type","value","arr","push","object","key","Date","source","flags","RegExp","map","Map","Set","add","name","message","BigInt","Object","Uint8Array","buffer","DataView","EMPTY","toString","keys","typeOf","asString","call","slice","includes","shouldSkip","_ref","TYPE","serialize","json","lossy","arguments","length","undefined","serializer","strict","pair","entry","TypeError","spread","valueOf","toJSON","entries","toISOString","structuredClone","any","options","ok","asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","code","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","unicodePunctuation","unicodeWhitespace","regex","test","String","fromCharCode","pointEnd","point","pointStart","node","position","line","column","offset","start","end","normalizeUri","result","skip","charCodeAt","replace","next","encodeURIComponent","join","defaultFootnoteBackContent","rereferenceIndex","tagName","properties","children","defaultFootnoteBackLabel","referenceIndex","revert","state","subtype","referenceType","suffix","label","identifier","alt","contents","all","head","unshift","tail","listItemLoose","trimLines","search","match","exec","last","lines","trimLine","startIndex","endIndex","codePointAt","handlers","blockquote","wrap","patch","applyData","break","lang","className","meta","data","delete","emphasis","footnoteReference","clobberPrefix","id","toUpperCase","safeId","toLowerCase","footnoteOrder","indexOf","counter","reuseCounter","footnoteCounts","link","href","dataFootnoteRef","ariaDescribedBy","sup","heading","depth","html","allowDangerousHtml","imageReference","definition","definitionById","src","url","title","image","inlineCode","text","linkReference","listItem","parent","results","loose","listLoose","checked","paragraph","disabled","child","list","Array","isArray","ordered","root","strong","table","rows","firstRow","shift","tableContent","body","tableCell","tableRow","siblings","align","cellIndex","cells","cell","alignValue","thematicBreak","toml","ignore","yaml","footnoteDefinition","own","hasOwnProperty","emptyOptions","from","to","hName","hChildren","hProperties","assign","defaultUnknownHandler","nodes","trimMarkdownSpaceStart","toHast","tree","settings","footnoteById","_objectSpread","defaultHandlers","values","one","handle","passThrough","shallow","_objectWithoutProperties","_excluded","unknownHandler","visit","createState","foot","footnoteBackContent","footnoteBackLabel","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","listItems","content","backReferences","counts","dataFootnoteBackref","ariaLabel","tailTail","dataFootnotes","footer","assert","remarkRehype","destination","async","file","hastTree","run"],"sourceRoot":""}